# Паттерны 

## 1. Что такое паттерн проектирования в контексте разработки программного обеспечения? Перечислите три основных типа паттернов проектирования и дайте краткое описание каждого. Как паттерны проектирования способствуют написанию легко поддерживаемого и масштабируемого кода?

### Что такое паттерн проектирования в контексте разработки программного обеспечения?

**Шаблоны проектирования** — это повторяемое решение типичных проблем, возникающих при проектировании и разработке программных систем. Они представляют собой структурированные шаблоны, которые могут быть использованы для решения конкретных проблем в рамках определенного контекста.

### Перечислите три основных типа паттернов проектирования и дайте краткое описание каждого.

**Порождающие** 

Порождающие паттерны описывают создание объекта или группы связанных объектов. Они помогают решить архитектурные проблемы, упрощая её.

**Структурные**

Структурные паттерны в основном посвящены компоновке объектов (object composition). То есть тому, как сущности могут друг друга использовать. Они определяют простой способ реализации взаимоотношений между сущностями.

**Поведенческие**

Поведенческие паттерны связаны с присвоением обязанностей (responsibilities) объектам. От структурных шаблонов они отличаются тем, что не просто описывают структуру, но и очерчивают шаблоны передачи данных, обеспечения взаимодействия. То есть поведенческие шаблоны позволяют ответить на вопрос «Как реализовать поведение в программном компоненте?». Определением алгоритмов и способов реализации взаимодействия между объектами они обеспечивают гибкость взаимодействия между объектами.

### Как паттерны проектирования способствуют написанию легко поддерживаемого и масштабируемого кода?

- Способствуют тому, что код легче поддаётся изменениям, ведь изменения в чистом коде затрагивают конкретные участки кода, и не придётся делать много изменений изменений в системе
- Изменения не будут "ломать" программу, ведь не будут затрагивать иные участки кода
- Легче разделить код на компоненты, которые могут использоваться в других системах
- Помогают избавиться от повторяющегося кода
- Помогают сделать код структурированным, читабельным и понятным

## 2. Опишите паттерн Singleton и сценарии, в которых его применение оправдано. Какие проблемы могут возникнуть при использовании Singleton в многопоточной среде? Приведите пример реализации Singleton в Java/Kotlin.

### Опишите паттерн Singleton и сценарии, в которых его применение оправдано.

**Синглтон** — это **порождающий** шаблон проектирования, который позволяет гарантировать, что класс имеет только один экземпляр, обеспечивая при этом глобальную точку доступа к этому экземпляру.

**Оправданное применение:**

- Шаблон **Singleton** используется, когда класс в программе должен иметь только один экземпляр, доступный всем клиентам; например, один объект базы данных, используемый разными частями программы
- Когда нужен доступ к объекту из разных частей приложения без передачи его по всему коду
- Для обеспечения доступа к ресурсам, которые могут быть общими для всего приложения

![image](https://github.com/flowykk/KPO-hse/assets/71427624/8b30d8c0-e028-4ede-99b0-5bb5be9fbb85)

### Проблемы при использовании Singleton в многопоточной среде?

- **Потокобезопасность:** Если не обеспечить атомарную инициализацию экземпляра Singleton, то возможно создание нескольких экземпляров в многопоточной среде.
- **Ленивая инициализация:** При ленивой инициализации (инициализации экземпляра только при первом обращении) необходимо обеспечить правильную синхронизацию для избежания создания нескольких экземпляров при одновременном обращении.

### Пример реализации Singleton

```kotlin
class Database is
    // The field for storing the singleton instance should be
    // declared static.
    private static field instance: Database

    // The singleton's constructor should always be private to
    // prevent direct construction calls with the `new`
    // operator.
    private constructor Database() is
        // Some initialization code, such as the actual
        // connection to a database server.
        // ...

    // The static method that controls access to the singleton
    // instance.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
                // Ensure that the instance hasn't yet been
                // initialized by another thread while this one
                // has been waiting for the lock's release.
                if (Database.instance == null) then
                    Database.instance = new Database()
        return Database.instance
```

![image](https://github.com/flowykk/KPO-hse/assets/71427624/941f7604-1b84-4ce8-bbd3-342a379c79d1)

## 3. Что такое паттерн Наблюдатель и в каких случаях его стоит применять? Какие преимущества дает использование паттерна Наблюдатель? Приведите пример, где этот паттерн может быть использован в приложении.

### Что такое паттерн Наблюдатель и в каких случаях его стоит применять? 

**Наблюдатель** - это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

**Применение**
- Этот паттерн используется, когда изменения состояния одного объекта могут потребовать изменения других объектов, а фактический набор объектов заранее неизвестен или изменяется динамически, то есть когда один объект должен оповещать множество других объектов без знания о них напрямую
- **Наблюдатель** используется, когда одни объекты в вашем приложении должны наблюдать за другими, но только в течение ограниченного времени или в особых случаях

### Какие преимущества дает использование паттерна Наблюдатель?

![image](https://github.com/flowykk/KPO-hse/assets/71427624/4f83c822-cac5-4793-bd2d-247f5ff5a5fb)

### Приведите пример, где этот паттерн может быть использован в приложении.

Например, реализация уведомлений в мессенджере. Когда пользователь отправляет сообщение, все его контакты, которые подписаны на его уведомления, автоматически получают уведомление о новом сообщении. В этом случае, мессенджер является объектом-издателем, а пользователи - объектами-подписчиками. Когда состояние объекта-издателя (новое сообщение) изменяется, все подписчики получают уведомление об этом изменении.

## 4. Объясните назначение и принцип работы паттерна Адаптер. В чем преимущество использования Адаптера при интеграции сторонних библиотек или API? Приведите пример кода, где паттерн Адаптер помогает взаимодействовать двум несовместимым интерфейсам.

### Объясните назначение и принцип работы паттерна Адаптер. 

**Адаптер** - структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

**Принцип работы:**
- Адаптер имеет интерфейс, который совместим с одним из объектов, поэтому уэтот объект может свободно вызывать методы адаптера
- Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту

Иногда возможно создать *двусторонний* адаптер, который работает по такому принципу в обе стороны

### В чем преимущество использования Адаптера при интеграции сторонних библиотек или API? 

- Позволяет интегрировать сторонние библиотеки или API без необходимости изменения исходного кода
- Сокращает затраты на адаптацию, так как позволяет использовать объекты с несовместимыми интерфейсами без изменения самих объектов
- Упрощает разработку и поддержку кода, так как адаптер выступает в качестве прозрачного промежуточного слоя

### Пример кода с использованием Adapter

```kotlin
// Интерфейс, ожидаемый клиентом
interface Printer {
    fun print(text: String)
}

// Класс, объекты которого нужно адаптировать
class LegacyPrinter {
    fun printDocument(text: String) {
        println("Printing document: $text")
    }
}

// Адаптер, преобразующий интерфейс LegacyPrinter в интерфейс Printer
class PrinterAdapter(private val legacyPrinter: LegacyPrinter) : Printer {
    override fun print(text: String) {
        legacyPrinter.printDocument(text)
    }
}

fun main() {
    // Используем адаптер для взаимодействия с классом LegacyPrinter
    val legacyPrinter = LegacyPrinter()
    val printer: Printer = PrinterAdapter(legacyPrinter)
    
    // Теперь мы можем использовать объект printer, ожидая интерфейс Printer
    printer.print("Hello, world!")
}
```

## 5. Опишите паттерн Стратегия и ситуации, где его применение целесообразно. В чем заключается гибкость паттерна Стратегия? Приведите пример кода с использованием паттерна Стратегия.

### Опишите паттерн Стратегия и ситуации, где его применение целесообразно. 

### В чем заключается гибкость паттерна Стратегия? 

### Приведите пример кода с использованием паттерна Стратегия.

## 6.  Определите паттерн Фабрика и объясните, зачем он нужен. Какие проблемы решает Фабричный метод, и как он отличается от Абстрактной Фабрики? Приведите пример реализации Фабричного метода.

### Определите паттерн Фабрика и объясните, зачем он нужен. 

### Какие проблемы решает Фабричный метод, и как он отличается от Абстрактной Фабрики? 

### Приведите пример реализации Фабричного метода.

## 7. Что такое паттерн Прокси и в каких случаях его использование наиболее оправдано? Опишите различия между статическим и динамическим прокси. Приведите пример использования Прокси в программе.

## Что такое паттерн Прокси и в каких случаях его использование наиболее оправдано? 

## Опишите различия между статическим и динамическим прокси. 

## Приведите пример использования Прокси в программе.

# Многопоточность

# Сеть

## 1. Что такое REST? Каковы условия того, чтобы считать API RESTful? (назовите 3-4 принципа)

### Что такое REST?

**REST (Representational State Transfer)** — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы.

### 6 принципов REST

- **Клиент-серверная архитектура:** Клиент и сервер разделены, что позволяет каждой стороне развиваться независимо. Клиент не зависит от реализации сервера, а сервер не зависит от клиента.

- **Stateless:** Cервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

- **Кэширование:** Ответы сервера могут быть кешированы на стороне клиента. Это уменьшает количество запросов к серверу и улучшает производительность.

- **Единообразие интерфейса:** Одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

- **Layered system:** Между клиентом и сервером могут быть и другие слои, к примеру, proxy-сервера, роутеры, балансировщики и т.д.. Ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей. Если изменяется поведение одного из слоёв, это не должно повлечь изменения для клиентского приложения или для сервера. Помещая их в эту цепочку вызовов, мы не должны замечать никакой разницы. Это позволяет нам изменять общую архитектуру без доработок на стороне клиента или сервера.

- **Code on demand:** Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту. Клиент, запрашивая данную страницу приветствия, получит в ответ от сервера не просто, например, HTML-код для отображения, а ещё программу, которую он сам и исполнит. Получается, что сервер передаёт исходный код клиенту, а тот его выполняет.

## 2. Какие HTTP методы обычно используются в RESTful API и для каких операций они применяются?

- **GET:** Используется для получения данных от сервера. Это безопасный метод, который не изменяет состояние сервера. Он часто используется для получения информации о ресурсе или коллекции ресурсов.

- **POST:** Используется для создания нового ресурса на сервере. Данные для создания нового ресурса передаются в теле запроса. Этот метод может изменять состояние сервера.

- **PUT:** Используется для обновления существующего ресурса на сервере. Данные для обновления ресурса передаются в теле запроса. Этот метод может изменять состояние сервера.

- **DELETE:** Используется для удаления ресурса на сервере. Этот метод может изменять состояние сервера.

- **PATCH:** Используется для частичного обновления ресурса на сервере. В отличие от PUT, который требует передачи полного представления ресурса для обновления, PATCH позволяет отправить только измененные части ресурса. Этот метод может изменять состояние сервера.

- **OPTIONS:** Используется для получения информации о возможностях ресурса или коллекции ресурсов. Этот метод не изменяет состояние сервера и может использоваться для получения информации о поддерживаемых методах HTTP для конкретного ресурса.

- **HEAD:** Похож на GET, но возвращает только заголовки ответа, без тела ответа. Это может быть полезно для проверки доступности ресурса или получения метаданных о ресурсе без необходимости загружать его содержимое.

## 3. Дайте определение HTTP. В чем разница между HTTP/1.1 и HTTP/2?

### Что такое HTTP?

**HTTP (HyperText Transfer Protocol)** — это протокол передачи данных в интернете. Изначально для передачи данных в виде гипертекстовых документов в формате HTML, сегодня — для передачи произвольных данных.

### Разница между HTTP/1.1 и HTTP/2

## 4. Дайте определение TCP и UDP. В чем разница между ними?

## 5. Что такое gRPC и в каких случаях он широко используется в разработке приложений? В чем отличие между gRPC и RESTful API?

## 6. Как gRPC обеспечивает эффективность передачи данных по сравнению с REST? Что такое Protocol Buffers и как они используются в gRPC для определения сообщений и сервисов?

# БД

## 1. Дайте определение ORM. Какие преимущества предоставляет использование ORM при работе с базой данных?

**ORM (Object-relational mapping)** - это способ (он же шаблон проектирования) доступа к реляционной базе данных с помощью объектно-ориентированного языка. То есть прослойка между БД и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд.

**Преимущества**
- Для реализации одинакового функционала требуется написать меньше кода.
- Не нужно писать SQL запросы. + может оптимизировать запросы к БД, используя кэширование, оптимизацию запросов и другие техники, что может улучшить производительность приложенияю
- Сокращает время тестирования. Нет необходимости вручную преобразовывать объекты из/в БД, а код, который делает такое преобразование, написан
и уже протестирован
- ORM позволяет легко переносить приложения между различными базами данных, изменяя только конфигурацию ORM, а не код приложения. Это уменьшает время и усилия, необходимые для поддержки приложений на разных платформах.

## 2. Из каких элементов состоит ERM? В чем цель составления такой модели?

ERM (Entity-Relationship Model) — это концептуальная модель, используемая в проектировании баз данных для представления структуры данных и отношений между сущностями.

### Элементы ERM

- **Сущности (Entities):** Сущности представляют объекты или концепции, которые могут быть идентифицированы и о которых можно хранить информацию. 

- **Атрибуты (Attributes):** Атрибуты — это свойства или характеристики сущностей. 

- **Отношения (Relationships):** Отношения определяют связи между сущностями. Они могут быть один-к-одному, один-ко-многим, многие-ко-многим. 

- **Ключи (Keys):** Ключи используются для идентификации сущностей и отношений. Существуют два основных типа ключей: первичные ключи (Primary Keys), которые уникально идентифицируют каждую сущность, и внешние ключи (Foreign Keys), которые ссылаются на первичные ключи других сущностей для установления отношений между сущностями.

### Цель ERM

**Цель составления ERM** — это визуализация структуры данных и отношений между сущностями в проекте базы данных. ERM помогает разработчикам и аналитикам понять, как данные связаны между собой, и определить, как эти данные должны быть организованы в БД. Это помогает в проектировании схемы базы данных, выборе правильных типов данных для атрибутов, определении ключей и отношений, а также в понимании требований к базе данных.

## 3. Какие типы связей сущностей вы знаете и как они представлены в ERM? Что такое сущность в Entity-Relationship модели?

### Типы связей сущностей

**Один-к-одному (One-to-One):** Каждый экземпляр одной сущности связан с одним и только одним экземпляром другой сущности, и наоборот. 

**Один-ко-многим (One-to-Many):** Один экземпляр одной сущности может быть связан с несколькими экземплярами другой сущности, но каждый экземпляр второй сущности связан только с одним экземпляром первой сущности. 

**Многие-ко-многим (Many-to-Many):** Это отношение, где множество экземпляров одной сущности могут быть связаны с множеством экземпляров другой сущности. 

### Вид представления связей 

<div align="center">
  <img src="https://github.com/flowykk/KPO-hse/assets/71427624/1b39b6f9-2a00-4fca-a3a5-d0ff5f9996eb" width="600"> 
</div>

### Что такое сущность в ERM?

- **Сущности (Entities):** Сущности представляют объекты или концепции, которые могут быть идентифицированы и о которых можно хранить информацию. 

- **Атрибуты (Attributes):** Атрибуты — это свойства или характеристики сущностей. 

## 4. В чем разница между логической и физической моделью базы данных? Что включает физическая модель?

## 5. Что такое JDBC? Какие основные шаги необходимо выполнить для установления подключения к базе данных с помощью JDBC?

## 6. Какие классы JDBC используются для выполнения SQL-запросов к базе данных? Опишите способы передачи параметров в SQL-запрос

## 7. Что такое транзакция? Зачем они нужны при выполнении операций с базой данных? Какой смысл носят слова commit и rollback в этом контексте?




