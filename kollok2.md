# Паттерны 

## 1. Что такое паттерн проектирования в контексте разработки программного обеспечения? Перечислите три основных типа паттернов проектирования и дайте краткое описание каждого. Как паттерны проектирования способствуют написанию легко поддерживаемого и масштабируемого кода?

### Что такое паттерн проектирования в контексте разработки программного обеспечения?

**Шаблоны проектирования** — это повторяемое решение типичных проблем, возникающих при проектировании и разработке программных систем. Они представляют собой структурированные шаблоны, которые могут быть использованы для решения конкретных проблем в рамках определенного контекста.

### Перечислите три основных типа паттернов проектирования и дайте краткое описание каждого.

**Порождающие** 

Порождающие паттерны описывают создание объекта или группы связанных объектов. Они помогают решить архитектурные проблемы, упрощая её.

**Структурные**

Структурные паттерны в основном посвящены компоновке объектов (object composition). То есть тому, как сущности могут друг друга использовать. Они определяют простой способ реализации взаимоотношений между сущностями.

**Поведенческие**

Поведенческие паттерны связаны с присвоением обязанностей (responsibilities) объектам. От структурных шаблонов они отличаются тем, что не просто описывают структуру, но и очерчивают шаблоны передачи данных, обеспечения взаимодействия. То есть поведенческие шаблоны позволяют ответить на вопрос «Как реализовать поведение в программном компоненте?». Определением алгоритмов и способов реализации взаимодействия между объектами они обеспечивают гибкость взаимодействия между объектами.

### Как паттерны проектирования способствуют написанию легко поддерживаемого и масштабируемого кода?

- Способствуют тому, что код легче поддаётся изменениям, ведь изменения в чистом коде затрагивают конкретные участки кода, и не придётся делать много изменений изменений в системе
- Изменения не будут "ломать" программу, ведь не будут затрагивать иные участки кода
- Легче разделить код на компоненты, которые могут использоваться в других системах
- Помогают избавиться от повторяющегося кода
- Помогают сделать код структурированным, читабельным и понятным

## 2. Опишите паттерн Singleton и сценарии, в которых его применение оправдано. Какие проблемы могут возникнуть при использовании Singleton в многопоточной среде? Приведите пример реализации Singleton в Java/Kotlin.

### Опишите паттерн Singleton

**Синглтон** — это **порождающий** шаблон проектирования, который позволяет гарантировать, что класс имеет только один экземпляр, обеспечивая при этом глобальную точку доступа к этому экземпляру.

### Оправданное применение

- Шаблон **Singleton** используется, когда класс в программе должен иметь только один экземпляр, доступный всем клиентам; например, один объект базы данных, используемый разными частями программы
- Когда нужен доступ к объекту из разных частей приложения без передачи его по всему коду
- Для обеспечения доступа к ресурсам, которые могут быть общими для всего приложения

![image](https://github.com/flowykk/KPO-hse/assets/71427624/8b30d8c0-e028-4ede-99b0-5bb5be9fbb85)

### Проблемы при использовании Singleton в многопоточной среде?

- **Потокобезопасность:** Если не обеспечить атомарную инициализацию экземпляра Singleton, то возможно создание нескольких экземпляров в многопоточной среде.
- **Ленивая инициализация:** При ленивой инициализации (инициализации экземпляра только при первом обращении) необходимо обеспечить правильную синхронизацию для избежания создания нескольких экземпляров при одновременном обращении.

### Пример реализации Singleton

```kotlin
class Database is
    // The field for storing the singleton instance should be
    // declared static.
    private static field instance: Database

    // The singleton's constructor should always be private to
    // prevent direct construction calls with the `new`
    // operator.
    private constructor Database() is
        // Some initialization code, such as the actual
        // connection to a database server.
        // ...

    // The static method that controls access to the singleton
    // instance.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
                // Ensure that the instance hasn't yet been
                // initialized by another thread while this one
                // has been waiting for the lock's release.
                if (Database.instance == null) then
                    Database.instance = new Database()
        return Database.instance
```

### + 

![image](https://github.com/flowykk/KPO-hse/assets/71427624/941f7604-1b84-4ce8-bbd3-342a379c79d1)

## 3. Что такое паттерн Наблюдатель и в каких случаях его стоит применять? Какие преимущества дает использование паттерна Наблюдатель? Приведите пример, где этот паттерн может быть использован в приложении.

### Что такое паттерн Наблюдатель

**Наблюдатель** - это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

### Применение

- Этот паттерн используется, когда изменения состояния одного объекта могут потребовать изменения других объектов, а фактический набор объектов заранее неизвестен или изменяется динамически, то есть когда один объект должен оповещать множество других объектов без знания о них напрямую
- **Наблюдатель** используется, когда одни объекты в вашем приложении должны наблюдать за другими, но только в течение ограниченного времени или в особых случаях

### Какие преимущества дает использование паттерна Наблюдатель?

![image](https://github.com/flowykk/KPO-hse/assets/71427624/4f83c822-cac5-4793-bd2d-247f5ff5a5fb)

### Приведите пример, где этот паттерн может быть использован в приложении.

Например, реализация уведомлений в мессенджере. Когда пользователь отправляет сообщение, все его контакты, которые подписаны на его уведомления, автоматически получают уведомление о новом сообщении. В этом случае, мессенджер является объектом-издателем, а пользователи - объектами-подписчиками. Когда состояние объекта-издателя (новое сообщение) изменяется, все подписчики получают уведомление об этом изменении.

## 4. Объясните назначение и принцип работы паттерна Адаптер. В чем преимущество использования Адаптера при интеграции сторонних библиотек или API? Приведите пример кода, где паттерн Адаптер помогает взаимодействовать двум несовместимым интерфейсам.

### Объясните назначение

**Адаптер** - структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

### Принцип работы
- Адаптер имеет интерфейс, который совместим с одним из объектов, поэтому уэтот объект может свободно вызывать методы адаптера
- Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту

Иногда возможно создать *двусторонний* адаптер, который работает по такому принципу в обе стороны

### В чем преимущество использования Адаптера при интеграции сторонних библиотек или API? 

- Позволяет интегрировать сторонние библиотеки или API без необходимости изменения исходного кода
- Сокращает затраты на адаптацию, так как позволяет использовать объекты с несовместимыми интерфейсами без изменения самих объектов
- Упрощает разработку и поддержку кода, так как адаптер выступает в качестве прозрачного промежуточного слоя

### Пример кода с использованием Adapter

```kotlin
// Интерфейс, ожидаемый клиентом
interface Printer {
    fun print(text: String)
}

// Класс, объекты которого нужно адаптировать
class LegacyPrinter {
    fun printDocument(text: String) {
        println("Printing document: $text")
    }
}

// Адаптер, преобразующий интерфейс LegacyPrinter в интерфейс Printer
class PrinterAdapter(private val legacyPrinter: LegacyPrinter) : Printer {
    override fun print(text: String) {
        legacyPrinter.printDocument(text)
    }
}

fun main() {
    // Используем адаптер для взаимодействия с классом LegacyPrinter
    val legacyPrinter = LegacyPrinter()
    val printer: Printer = PrinterAdapter(legacyPrinter)
    
    // Теперь мы можем использовать объект printer, ожидая интерфейс Printer
    printer.print("Hello, world!")
}
```

## 5. Опишите паттерн Стратегия и ситуации, где его применение целесообразно. В чем заключается гибкость паттерна Стратегия? Приведите пример кода с использованием паттерна Стратегия.

### Опишите паттерн Стратегия и ситуации

**Стратегия** - поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

### Применение

- Паттерн **Стратегия** используется, если вы хотите использовать различные варианты алгоритма внутри объекта и иметь возможность переключаться с одного алгоритма на другой во время выполнения
- Шаблон используется, когда у вас много похожих классов, которые отличаются только способом выполнения некоторого поведения
- Используйте шаблон, чтобы изолировать бизнес-логику класса от деталей реализации алгоритмов, которые могут быть не столь важны в контексте этой логики
- Паттерн используется, когда в вашем классе есть массивный условный оператор, который переключается между различными вариантами одного и того же алгоритма

### В чем заключается гибкость паттерна Стратегия? 

Гибкость паттерна заключается в том, что он позволяет добавлять новые стратегии без изменения контекста и клиентского кода. Клиент может выбирать нужную стратегию во время выполнения программы, в зависимости от изменяющихся условий или требований.

### Приведите пример кода с использованием паттерна Стратегия

```kotlin
// Интерфейс стратегии
interface PaymentStrategy {
    fun pay(amount: Int)
}

// Конкретная стратегия оплаты кредитной картой
class CreditCardPaymentStrategy(private val cardNumber: String, private val cvv: String) : PaymentStrategy {
    override fun pay(amount: Int) {
        println("Paying $amount using credit card $cardNumber")
    }
}

// Конкретная стратегия оплаты через PayPal
class PayPalPaymentStrategy(private val email: String, private val password: String) : PaymentStrategy {
    override fun pay(amount: Int) {
        println("Paying $amount using PayPal account $email")
    }
}

// Класс контекста, который использует стратегию оплаты
class ShoppingCart(private val paymentStrategy: PaymentStrategy) {
    fun checkout(amount: Int) {
        paymentStrategy.pay(amount)
    }
}

fun main() {
    // Создаем объекты стратегий
    val creditCardStrategy = CreditCardPaymentStrategy("1234567890123456", "123")
    val paypalStrategy = PayPalPaymentStrategy("example@example.com", "password")

    // Используем разные стратегии оплаты
    val cart1 = ShoppingCart(creditCardStrategy)
    cart1.checkout(100)

    val cart2 = ShoppingCart(paypalStrategy)
    cart2.checkout(200)
}
```

## 6.  Определите паттерн Фабрика и объясните, зачем он нужен. Какие проблемы решает Фабричный метод, и как он отличается от Абстрактной Фабрики? Приведите пример реализации Фабричного метода.

### Определите паттерн Фабрика

**Фабричный метод** - это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя изменять тип создаваемых объектов.

### Зачем нужна Фабрика?

- Упрощение процесса создания объектов, избавляя клиентский код от прямых зависимостей от конкретных классов
- Предоставления гибкости при создании объектов, позволяя подклассам решать, какой именно объект создавать
- Позволяет добавлять новые типы объектов без изменения существующего кода

### Какие проблемы решает Фабричный метод?

- **Уменьшение связанности кода:** клиентский код не зависит от конкретных классов создаваемых объектов.
- **Увеличение гибкости:** позволяет легко вносить изменения в способ создания объектов и добавлять новые типы объектов.
- **Повышение расширяемости:** новые типы объектов можно добавить, реализуя новые подклассы фабричного метода.

### Отличия от Абстрактной Фабрики? 

- **Фабричный метод** определяет метод создания объекта в абстрактном классе или интерфейсе и делегирует создание конкретных объектов подклассам. **Абстрактная Фабрика** определяет интерфейс для создания семейств взаимосвязанных объектов, не привязываясь к конкретным классам.
- **Фабричный метод** создает один объект, **Абстрактная фабрика** - семейство взаимосвязанных объектов.
- **Фабричный метод** использует наследование, чтобы делегировать создание объектов подклассам, в то время как **Абстрактная Фабрика** использует композицию, предоставляя клиенту объект фабрики, который создает семейство объектов.

### Приведите пример реализации Фабричного метода.

```kotlin
// Интерфейс продукта
interface Product {
    fun operation()
}

// Конкретные реализации продукта
class ConcreteProductA : Product {
    override fun operation() {
        println("Concrete Product A operation")
    }
}

class ConcreteProductB : Product {
    override fun operation() {
        println("Concrete Product B operation")
    }
}

// Абстрактный класс создателя (Фабричный метод)
abstract class Creator {
    abstract fun factoryMethod(): Product
    
    fun someOperation() {
        val product = factoryMethod()
        product.operation()
    }
}

// Конкретные реализации создателя
class ConcreteCreatorA : Creator() {
    override fun factoryMethod(): Product {
        return ConcreteProductA()
    }
}

class ConcreteCreatorB : Creator() {
    override fun factoryMethod(): Product {
        return ConcreteProductB()
    }
}

fun main() {
    val creatorA: Creator = ConcreteCreatorA()
    creatorA.someOperation() // Вывод: Concrete Product A operation
    
    val creatorB: Creator = ConcreteCreatorB()
    creatorB.someOperation() // Вывод: Concrete Product B operation
}
```

## 7. Что такое паттерн Прокси и в каких случаях его использование наиболее оправдано? Опишите различия между статическим и динамическим прокси. Приведите пример использования Прокси в программе.

## Что такое паттерн Прокси

**Прокси** - это структурный паттерн проектирования, который предоставляет заместитель или placeholder для другого объекта, чтобы контролировать доступ к нему. Прокси обеспечивает тот же интерфейс, что и реальный объект, и может выполнять некоторые дополнительные действия при доступе к нему.

## Оправданное применение

- **Ленивая инициализация (виртуальный прокси):** Это когда у вас есть тяжеловесный сервисный объект, который тратит системные ресурсы, постоянно находясь в рабочем состоянии, даже если он вам нужен только время от времени
- **Контроль доступа (прокси защиты):** Это когда вы хотите, чтобы только определенные клиенты могли использовать объект службы; например, когда ваши объекты являются важными частями операционной системы, а клиенты — различными запускаемыми приложениями (в том числе вредоносными)
- **Локальное выполнение удаленного сервиса (удаленный прокси):** Это когда объект службы находится на удаленном сервере. В этом случае прокси передает клиентский запрос по сети, беря на себя все неприятные детали работы с сетью
- **Запросы на регистрацию (прокси-сервер):** Это когда вы хотите вести историю запросов к сервисному объекту. Прокси-сервер может регистрировать каждый запрос перед его передачей в службу

## Опишите различия между статическим и динамическим прокси. 

- **Статический прокси** создается во время компиляции, а **Динамический** - во время выполнения.
- **Статический прокси** требует явного создания класса прокси для каждого интерфейса или объекта, в то время как **Динамический** прокси создается на основе интерфейса, который необходимо проксировать.
- **Динамический прокси** обеспечивает большую гибкость, так как не требует написания специальных классов прокси для каждого интерфейса.

## Приведите пример использования Прокси в программе.

```kotlin
// The interface of a remote service.
interface ThirdPartyYouTubeLib is
    method listVideos()
    method getVideoInfo(id)
    method downloadVideo(id)

// The concrete implementation of a service connector. Methods
// of this class can request information from YouTube. The speed
// of the request depends on a user's internet connection as
// well as YouTube's. The application will slow down if a lot of
// requests are fired at the same time, even if they all request
// the same information.
class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib is
    method listVideos() is
        // Send an API request to YouTube.

    method getVideoInfo(id) is
        // Get metadata about some video.

    method downloadVideo(id) is
        // Download a video file from YouTube.

// To save some bandwidth, we can cache request results and keep
// them for some time. But it may be impossible to put such code
// directly into the service class. For example, it could have
// been provided as part of a third party library and/or defined
// as `final`. That's why we put the caching code into a new
// proxy class which implements the same interface as the
// service class. It delegates to the service object only when
// the real requests have to be sent.
class CachedYouTubeClass implements ThirdPartyYouTubeLib is
    private field service: ThirdPartyYouTubeLib
    private field listCache, videoCache
    field needReset

    constructor CachedYouTubeClass(service: ThirdPartyYouTubeLib) is
        this.service = service

    method listVideos() is
        if (listCache == null || needReset)
            listCache = service.listVideos()
        return listCache

    method getVideoInfo(id) is
        if (videoCache == null || needReset)
            videoCache = service.getVideoInfo(id)
        return videoCache

    method downloadVideo(id) is
        if (!downloadExists(id) || needReset)
            service.downloadVideo(id)

// The GUI class, which used to work directly with a service
// object, stays unchanged as long as it works with the service
// object through an interface. We can safely pass a proxy
// object instead of a real service object since they both
// implement the same interface.
class YouTubeManager is
    protected field service: ThirdPartyYouTubeLib

    constructor YouTubeManager(service: ThirdPartyYouTubeLib) is
        this.service = service

    method renderVideoPage(id) is
        info = service.getVideoInfo(id)
        // Render the video page.

    method renderListPanel() is
        list = service.listVideos()
        // Render the list of video thumbnails.

    method reactOnUserInput() is
        renderVideoPage()
        renderListPanel()

// The application can configure proxies on the fly.
class Application is
    method init() is
        aYouTubeService = new ThirdPartyYouTubeClass()
        aYouTubeProxy = new CachedYouTubeClass(aYouTubeService)
        manager = new YouTubeManager(aYouTubeProxy)
        manager.reactOnUserInput()
```

# Многопоточность

# Сеть

## 1. Что такое REST? Каковы условия того, чтобы считать API RESTful? (назовите 3-4 принципа)

### Что такое REST?

**REST (Representational State Transfer)** — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы.

### 6 принципов REST

- **Клиент-серверная архитектура:** Клиент и сервер разделены, что позволяет каждой стороне развиваться независимо. Клиент не зависит от реализации сервера, а сервер не зависит от клиента.

- **Stateless:** Cервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

- **Кэширование:** Ответы сервера могут быть кешированы на стороне клиента. Это уменьшает количество запросов к серверу и улучшает производительность.

- **Единообразие интерфейса:** Одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

- **Layered system:** Между клиентом и сервером могут быть и другие слои, к примеру, proxy-сервера, роутеры, балансировщики и т.д.. Ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей. Если изменяется поведение одного из слоёв, это не должно повлечь изменения для клиентского приложения или для сервера. Помещая их в эту цепочку вызовов, мы не должны замечать никакой разницы. Это позволяет нам изменять общую архитектуру без доработок на стороне клиента или сервера.

- **Code on demand:** Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту. Клиент, запрашивая данную страницу приветствия, получит в ответ от сервера не просто, например, HTML-код для отображения, а ещё программу, которую он сам и исполнит. Получается, что сервер передаёт исходный код клиенту, а тот его выполняет.

## 2. Какие HTTP методы обычно используются в RESTful API и для каких операций они применяются?

- **GET:** Используется для получения данных от сервера. Это безопасный метод, который не изменяет состояние сервера. Он часто используется для получения информации о ресурсе или коллекции ресурсов.

- **POST:** Используется для создания нового ресурса на сервере. Данные для создания нового ресурса передаются в теле запроса. Этот метод может изменять состояние сервера.

- **PUT:** Используется для обновления существующего ресурса на сервере. Данные для обновления ресурса передаются в теле запроса. Этот метод может изменять состояние сервера.

- **DELETE:** Используется для удаления ресурса на сервере. Этот метод может изменять состояние сервера.

- **PATCH:** Используется для частичного обновления ресурса на сервере. В отличие от PUT, который требует передачи полного представления ресурса для обновления, PATCH позволяет отправить только измененные части ресурса. Этот метод может изменять состояние сервера.

- **OPTIONS:** Используется для получения информации о возможностях ресурса или коллекции ресурсов. Этот метод не изменяет состояние сервера и может использоваться для получения информации о поддерживаемых методах HTTP для конкретного ресурса.

- **HEAD:** Похож на GET, но возвращает только заголовки ответа, без тела ответа. Это может быть полезно для проверки доступности ресурса или получения метаданных о ресурсе без необходимости загружать его содержимое.

## 3. Дайте определение HTTP. В чем разница между HTTP/1.1 и HTTP/2?

### Что такое HTTP?

**HTTP (HyperText Transfer Protocol)** — это протокол передачи данных в интернете. Изначально для передачи данных в виде гипертекстовых документов в формате HTML, сегодня — для передачи произвольных данных.

### Разница между HTTP/1.1 и HTTP/2

**HTTP/1.1** был стандартом для передачи данных в Интернете на протяжении многих лет, но он имеет ряд ограничений, которые могут снижать производительность и масштабируемость веб-приложений. **HTTP/2** был разработан для устранения этих ограничений и предлагает ряд улучшений:

- Множественные потоки: В **HTTP/1.1** каждый запрос обрабатывается последовательно, что может привести к задержкам, особенно в условиях высокой загрузки. **HTTP/2** позволяет обрабатывать несколько запросов одновременно в рамках одного соединения, что улучшает производительность.
- Сжатие заголовков: **HTTP/1.1** требует отправку заголовков для каждого запроса, что может быть неэффективным, особенно если заголовки остаются неизменными между запросами. **HTTP/2** использует сжатие заголовков для уменьшения объема передаваемых данных.
- Приоритизация запросов: В **HTTP/1.1** запросы обрабатываются в порядке их поступления, что может привести к задержкам для менее важных запросов. **HTTP/2** позволяет клиенту указывать приоритеты запросов, чтобы сервер мог обрабатывать более важные запросы первыми.
- Серверный пуш: **HTTP/2** вводит концепцию серверного пуша, позволяя серверу активно отправлять данные клиенту без предварительного запроса. Это может улучшить время загрузки веб-страниц, отправляя данные заранее.
- Бинарный протокол: В отличие от **HTTP/1.1**, который использует текстовый протокол, **HTTP/2** является бинарным протоколом. Это упрощает обработку и уменьшает объем передаваемых данных.

**HTTP/2** был разработан для улучшения производительности и масштабируемости веб-приложений, устраняя некоторые из ограничений **HTTP/1.1**. Однако, несмотря на эти улучшения, **HTTP/2** требует поддержки со стороны клиента и сервера, и не все клиенты и серверы могут поддерживать **HTTP/2**.

## 4. Дайте определение TCP и UDP. В чем разница между ними?

**TCP (Transmission Control Protocol)** 

- Протокол надежной и упорядоченной доставки данных
- Обеспечивает контроль передачи данных, управление потоком, обнаружение ошибок и повторную передачу данных при необходимости

**UDP (User Datagram Protocol)**

- Простой протокол без гарантии доставки данных, контроля потока или механизмов повторной передачи данных
- Представляет собой менее надежную альтернативу TCP

### Разница между TCP и UDP

- **Надежность:** TCP обеспечивает надежную передачу данных, используя механизмы подтверждения получения, повторной передачи потерянных пакетов и контроля потока. UDP не предоставляет таких гарантий, что делает его более подходящим для приложений, где скорость важнее надежности, например, в потоковом видео или игровых приложениях
- **Соединение:** TCP использует соединение для обмена данными между отправителем и получателем, что обеспечивает упорядоченную и безошибочную передачу. UDP не использует соединение, что позволяет ему быстрее передавать данные, но также означает, что он не может гарантировать упорядоченность или доставку данных
- **Заголовки:** TCP заголовки содержат больше информации, чем UDP заголовки, включая номера последовательности, контрольные суммы и флаги управления соединением. UDP заголовки значительно меньше и содержат только порты отправителя и получателя
- **Применение:** TCP часто используется в приложениях, где важна надежность и целостность данных, таких как веб-сервисы, электронная почта и файловые передачи. UDP часто используется в приложениях, где скорость важнее, и потеря некоторых пакетов приемлема, например, в потоковом видео, онлайн-играх и VoIP

## 5. Что такое gRPC и в каких случаях он широко используется в разработке приложений? В чем отличие между gRPC и RESTful API?

### Что такое gRPC?

**gRPC (Remote Procedure Call)** — это высокопроизводительный, открытый и общий фреймворк для удаленного вызова процедур (RPC), разработанный Google. gRPC использует протокол HTTP/2 для передачи данных, что позволяет ему обеспечивать низкую задержку и высокую пропускную способность. gRPC поддерживает автоматическую генерацию кода для различных языков программирования из определений интерфейсов, что упрощает разработку и поддержку API.

### Случаи применения

- **Микросервисы:** gRPC идеально подходит для разработки микросервисов, поскольку он позволяет легко создавать и использовать API между различными сервисами
- **Высокопроизводительные приложения:** Благодаря использованию HTTP/2 и бинарного формата передачи данных, gRPC обеспечивает высокую производительность и эффективность по сравнению с традиционными HTTP-сервисами
- **Межсерверное взаимодействие:** gRPC может использоваться для обеспечения взаимодействия между серверами в распределенных системах, обеспечивая надежность и эффективность
- **Мобильные приложения:** gRPC может использоваться для создания API для мобильных приложений, обеспечивая быструю и эффективную передачу данных

### Отличие между gRPC и RESTful API

- **Принцип взаимодействия:** В gRPC используются методы и сообщения, определенные в файлах .proto (удалённые вызовы процедур), что позволяет автоматически генерировать код для различных языков программирования. В RESTful API операции определяются через URL и HTTP-методы, а данные передаются в теле запроса или ответа
- **Производительность:** gRPC обеспечивает более высокую производительность по сравнению с RESTful API благодаря использованию HTTP/2 и бинарного формата данных
- **Протокол:** gRPC использует HTTP/2, который позволяет использовать бинарный формат передачи данных и поддерживает множественные потоки, в то время как RESTful API обычно использует HTTP/1.1.

## 6. Как gRPC обеспечивает эффективность передачи данных по сравнению с REST? Что такое Protocol Buffers и как они используются в gRPC для определения сообщений и сервисов?

### Как gRPC обеспечивает эффективность передачи данных по сравнению с REST?

- **Использование HTTP/2:** В отличие от REST, который обычно использует HTTP/1.1, gRPC использует HTTP/2. HTTP/2 предлагает ряд преимуществ, включая множественные потоки, что позволяет одновременно передавать несколько сообщений в одном соединении, и сжатие заголовков, что уменьшает объем передаваемых данных
- **Бинарный формат данных:** gRPC использует Protocol Buffers (Protobuf) в качестве формата данных, который является более эффективным и компактным по сравнению с JSON или XML, часто используемыми в REST
- **Сжатие данных:** gRPC может использовать сжатие данных для уменьшения объема передаваемых данных, что особенно полезно в условиях высокой загрузки
- **Протокол-ориентированный:** gRPC использует определения интерфейсов (в формате .proto), что позволяет автоматически генерировать код для различных языков программирования, упрощая разработку и поддержку API

### Что такое Protocol Buffers?

**Protocol Buffers (Protobuf)** — это бинарный формат сериализации данных, разработанный Google. Он позволяет определять структуры данных в виде простых текстовых файлов, которые затем могут быть скомпилированы в код на различных языках программирования. Protobuf обеспечивает высокую производительность и эффективность по сравнению с традиционными текстовыми форматами, такими как JSON или XML.

### Использование Protobuf в gRPC для определения сообщений и сервисов?

В gRPC Protobuf используется для определения сообщений и сервисов. Определения в Protobuf описывают структуру данных, которые будут передаваться между клиентом и сервером, а также интерфейсы сервисов, которые определяют доступные методы и их параметры.

- В .proto файлах указываются методы API, их входные и выходные параметры, а также типы передачи данных (например, уточнение, что используется бинарная передача данных)
- После компиляции, сгенерированный код предоставляет клиентам и серверам удобный способ взаимодействия через определенные API методы

# БД

## 1. Дайте определение ORM. Какие преимущества предоставляет использование ORM при работе с базой данных?

**ORM (Object-relational mapping)** - это способ (он же шаблон проектирования) доступа к реляционной базе данных с помощью объектно-ориентированного языка. То есть прослойка между БД и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд.

**Преимущества**
- Для реализации одинакового функционала требуется написать меньше кода.
- Не нужно писать SQL запросы. + может оптимизировать запросы к БД, используя кэширование, оптимизацию запросов и другие техники, что может улучшить производительность приложенияю
- Сокращает время тестирования. Нет необходимости вручную преобразовывать объекты из/в БД, а код, который делает такое преобразование, написан
и уже протестирован
- ORM позволяет легко переносить приложения между различными базами данных, изменяя только конфигурацию ORM, а не код приложения. Это уменьшает время и усилия, необходимые для поддержки приложений на разных платформах.

## 2. Из каких элементов состоит ERM? В чем цель составления такой модели?

ERM (Entity-Relationship Model) — это концептуальная модель, используемая в проектировании баз данных для представления структуры данных и отношений между сущностями.

### Элементы ERM

- **Сущности (Entities):** Сущности представляют объекты или концепции, которые могут быть идентифицированы и о которых можно хранить информацию
- **Атрибуты (Attributes):** Атрибуты — это свойства или характеристики сущностей
- **Отношения (Relationships):** Отношения определяют связи между сущностями. Они могут быть один-к-одному, один-ко-многим, многие-ко-многим

- **Ключи (Keys):** Ключи используются для идентификации сущностей и отношений. Существуют два основных типа ключей: первичные ключи (Primary Keys), которые уникально идентифицируют каждую сущность, и внешние ключи (Foreign Keys), которые ссылаются на первичные ключи других сущностей для установления отношений между сущностями.

### Цель ERM

**Цель составления ERM** — это визуализация структуры данных и отношений между сущностями в проекте базы данных. ERM помогает разработчикам и аналитикам понять, как данные связаны между собой, и определить, как эти данные должны быть организованы в БД. Это помогает в проектировании схемы базы данных, выборе правильных типов данных для атрибутов, определении ключей и отношений, а также в понимании требований к базе данных.

## 3. Какие типы связей сущностей вы знаете и как они представлены в ERM? Что такое сущность в Entity-Relationship модели?

### Типы связей сущностей

**Один-к-одному (One-to-One):** Каждый экземпляр одной сущности связан с одним и только одним экземпляром другой сущности, и наоборот. 

**Один-ко-многим (One-to-Many):** Один экземпляр одной сущности может быть связан с несколькими экземплярами другой сущности, но каждый экземпляр второй сущности связан только с одним экземпляром первой сущности. 

**Многие-ко-многим (Many-to-Many):** Это отношение, где множество экземпляров одной сущности могут быть связаны с множеством экземпляров другой сущности. 

### Вид представления связей 

<div align="center">
  <img src="https://github.com/flowykk/KPO-hse/assets/71427624/1b39b6f9-2a00-4fca-a3a5-d0ff5f9996eb" width="600"> 
</div>

### Что такое сущность в ERM?

- **Сущности (Entities):** Сущности представляют объекты или концепции, которые могут быть идентифицированы и о которых можно хранить информацию. 

- **Атрибуты (Attributes):** Атрибуты — это свойства или характеристики сущностей. 

## 4. В чем разница между логической и физической моделью базы данных? Что включает физическая модель?

**Логическая модель данных** — это абстрактное представление структуры данных и отношений между сущностями. Она включает в себя все сущности, атрибуты, ключи и взаимосвязи, которые представляют бизнес-информацию и определяют бизнес-правила.

**Физическая модель данных** - это конкретное представление структуры данных. Включает в себя все необходимые таблицы, столбцы, связи, свойства базы данных для физической реализации баз данных. Производительность базы данных, стратегия индексации, физическое хранилище и денормализация — важные параметры физической модели.

### Разница между логической и физической моделью базы данных

- **Специфичность:** Логическая модель обычно независима от конкретной СУБД и может быть использована для проектирования баз данных на различных платформах. Физическая модель специфична для конкретной СУБД и может включать в себя детали, специфичные для этой СУБД
- **Абстракция:** Логическая модель представляет данные и их отношения на более высоком уровне абстракции, не затрагивая детали физического хранения. Физическая модель, напротив, содержит детали о том, как данные хранятся и обрабатываются на физическом уровне
- **Применение:** Логическая модель используется для проектирования баз данных и определения структуры данных. Физическая модель используется для реализации базы данных в СУБД, включая создание таблиц, индексов и других объектов базы данных

### + 

<img width="867" alt="image" src="https://github.com/flowykk/KPO-hse/assets/71427624/5e25106a-be17-4794-b694-f576b0b3126a">

### Что включает в себя физическая модель?

- **Таблицы:** Структуры данных, которые хранят информацию в виде строк и столбцов
- **Индексы:** Структуры данных, которые ускоряют поиск данных в таблицах
- **Ограничения:** Правила, которые определяют, какие данные могут быть вставлены в таблицы, и как они должны быть связаны друг с другом
- **Процедуры и функции:** Код, который может быть выполнен в базе данных для обработки данных
- **Представления:** Виртуальные таблицы, созданные на основе данных из одной или нескольких таблиц
- **Триггеры:** Специальные процедуры, которые автоматически выполняются при определенных событиях, таких как вставка, обновление или удаление данных в таблице

## 5. Что такое JDBC? Какие основные шаги необходимо выполнить для установления подключения к базе данных с помощью JDBC?

#### Что такое JDBC?

**JDBC (Java Database Connectivity)** — стандарт взаимодействия приложиния с различными СУБД. Это API (Application Programming Interface), предоставляемый Java, который позволяет Java-приложениям подключаться к базам данных и выполнять SQL-запросы. JDBC предоставляет стандартный способ взаимодействия с базами данных из Java-приложений, независимо от используемой СУБД (системы управления базами данных).

#### Какие основные шаги необходимо выполнить для установления подключения к базе данных с помощью JDBC?

- **Загрузка драйвера JDBC:** Для подключения к базе данных с помощью JDBC необходимо загрузить соответствующий JDBC-драйвер. Драйверы JDBC обычно предоставляются производителями СУБД и могут быть загружены как JAR-файлы
- **Установление соединения:** После загрузки драйвера создается соединение с базой данных. Для этого используется URL-адрес базы данных, имя пользователя и пароль
- **Создание объекта Statement:** Для выполнения SQL-запросов создается объект Statement. Этот объект может быть использован для выполнения запросов, которые не возвращают результаты (например, INSERT, UPDATE, DELETE), или для получения результатов запросов (например, SELECT)
- **Выполнение SQL-запроса:** С помощью объекта Statement выполняется SQL-запрос. Если запрос возвращает результаты, можно использовать объект ResultSet для их обработки
- **Обработка результатов:** Если SQL-запрос возвращает результаты, они могут быть обработаны с помощью объекта ResultSet
- **Закрытие ресурсов:** После завершения работы с базой данных необходимо закрыть все открытые ресурсы, такие как объекты Statement, ResultSet и Connection, чтобы освободить ресурсы системы

### ИЛИ

- Открыть соединение
- Открыть курсор
- Отправить запрос
- Обработать набор данных
- Закрыть результирующий набор / курсор
- Закрыть соединение

## 6. Какие классы JDBC используются для выполнения SQL-запросов к базе данных? Опишите способы передачи параметров в SQL-запрос

### Используемые классы 

- **Connection:** Представляет соединение с базой данных. Создается с помощью драйвера JDBC и используется для создания объектов Statement и PreparedStatement
- **Statement:** Используется для выполнения простых SQL-запросов, которые не требуют параметров
- **PreparedStatement:** Расширяет класс Statement и используется для выполнения параметризованных SQL-запросов. Параметризованные запросы позволяют повысить производительность и безопасность, предотвращая SQL-инъекции
- **ResultSet:** Представляет результаты выполнения SQL-запросов, которые возвращают данные. Используется для извлечения данных из базы данных

### Способы передачи параметров в SQL-запрос

- SetInt
- SetString
- setBigDecimal
- setBoolean
- setDate
- setDouble
- setFloat
- setLong
- setNull
- setTime

## 7. Что такое транзакция? Зачем они нужны при выполнении операций с базой данных? Какой смысл носят слова commit и rollback в этом контексте?

### Что такое транкзакция? 

**Транзакция** — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку.

### Зачем они нужны?

### Какой смысл носят слова commit и rollback?
