## Тема 1. Основы языка UML 

### Что такое UML и каково его основное назначение? 
Ответ:

### Какие основные типы диаграмм используются в UML? Объясните, для чего эти диаграммы применяются. 
Ответ:

### Какой функционал необходимо описать при моделировании системы заказов доставки посылок? 
Ответ:

### Кратко опишите, какие классы необходимы для моделирования системы заказов посылок? Какие связи необходимы между классами? 
Ответ:

### Кратко опишите диаграмму последовательностей̆ для прецедента авторизации пользователя. 
Ответ:

### Кратко опишите диаграмму активностей для прецедента авторизации пользователя. 
Ответ:

## Тема 2. Основы языка программирования Kotlin 

### Зачем нужны классы? Как создаются классы в Kotlin? Что такое блок init? Что такое primary constructor? В каком порядке они вызываются? 
Классы в Kotlin объявляются с использованием ключевого слова class:

```kt
class Person { /*...*/ }
```
Объявление класса состоит из имени класса, заголовка класса (определения его типовых параметров, основного конструктора и некоторых других вещей) и тела класса, заключенного в фигурные скобки `{}`. 

Как заголовок, так и тело являются необязательными; если у класса нет тела, фигурные скобки можно опустить. Тогда получится пустой класс
```kt
class Empty
```

Класс имеет **primary-конструктор** и, возможно, один или несколько **secondary-конструкторов**. Основной конструктор объявляется в заголовке класса и следует за именем класса с ключевым словом `constructor` и необязательными типовыми параметрами.
```kt
class Person constructor(firstName: String) { /*...*/ }
```

Если основной конструктор не имеет аннотаций (`@`) или модификаторов видимости, ключевое слово constructor можно опустить:
```kt
class Person(firstName: String) { /*...*/ }
```

Заголовок класса не может содержать выполняемый код. Поэтому, если нужно выполнять какой-то код во время создания объекта, можно использовать блоки инициализации `init` внутри тела класса. Блоки инициализации объявляются с использованием ключевого слова `init`, за которым следуют фигурные скобки, а внутри них - код, который будет выполняться при создании объектов класса.

Во время инициализации экземпляра блоки инициализации выполняются в том же порядке, в котором они появляются в теле класса:

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints $name")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
```

При создании экземпляра класса в Kotlin сначала вызывается `primary-конструктор`, затем выполняется блок `init` (если он присутствует). 

### Какими способами можно создать свойство в Kotlin? Зачем классам нужны свойства? 

Свойства в классах Kotlin могут быть объявлены либо как изменяемые (`mutable`), с использованием ключевого слова var, либо как доступные только для чтения (`read-only`), с использованием ключевого слова val.

```kotlin
class Address {
    var name: String = "Холмс, Шерлок"
    var street: String = "Бейкер"
    var city: String = "Лондон"
    var state: String? = null
    var zip: String = "123456"
}
```

Полный синтаксис объявления свойства выглядит следующим образом:
```kotlin
var <имяСвойства>[: <ТипСвойства>] [= <инициализаторСвойства>]
    [<геттер>]
    [<сеттер>]
```

Указывание инициализатора, `getter'а` и `setter'a` является необязательным. Тип свойства также необязателен, если его можно вывести из инициализатора или возвращаемого типа геттера, как показано ниже:
```kotlin
var initialized = 1 // имеет тип Int, геттер и сеттер по умолчанию
// var allByDefault // ОШИБКА: требуется явный инициализатор, подразумеваются геттер и сеттер по умолчанию
```

При определении собственного `getter'a`, он будет вызываться каждый раз при доступе к свойству (таким образом, можно реализовать вычисляемое свойство).
```kotlin
class Rectangle(val width: Int, val height: Int) {
    val area: Int // тип свойства необязателен, так как его можно вывести из возвращаемого типа геттера
        get() = this.width * this.height
}
```

Вы можете опустить тип свойства, если его можно вывести из `getter'a`:
```kotlin
val area get() = this.width * this.height
```

При определении собственного `setter'a`, он будет вызываться каждый раз при присвоении значения свойству, за исключением его инициализации. Собственный `setter` выглядит следующим образом:
```kotlin
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // разбирает строку и присваивает значения другим свойствам
    }
```
По соглашению, имя параметра сеттера - `value`, но можно выбрать другое имя, если предпочтительно.

Свойства можно инициализировать из основного конструктора, при этом можно задать им значения по умолчанию:
```kotlin
class Person(val firstName: String, val lastName: String, var isEmployed: Boolean = true)
```

#### Дополнительно

Если вам нужно аннотировать аксессор или изменить его видимость, но вы не хотите изменять реализацию по умолчанию, вы можете определить аксессор, не определяя его тело:
```kotlin
var setterVisibility: String = "abc"
    private set // сеттер является закрытым и имеет реализацию по умолчанию

var setterWithAnnotation: Any? = null
    @Inject set // аннотируйте сеттер аннотацией Inject
```

### Зачем применяют наследование? Как наследуются интерфейсы и классы в Kotlin? 
[Источник](https://kotlinlang.ru/docs/inheritance.html)
Наследование в программировании предоставляет механизм создания новых классов на основе существующих (родительских) классов. Это позволяет создавать иерархии классов, где новые классы могут наследовать свойства и методы родительских классов, а также добавлять или переопределять их.

Основные цели применения наследования:
- **Повторное использование кода**: Наследование позволяет создавать новые классы на основе существующих, повторно используя их функциональность.
- **Структурирование кода**: Иерархии классов помогают организовать код и создавать абстракции, которые отражают отношения между различными объектами.

### Что такое null-безопасность в Kotlin? Зачем она нужна? 
Система типов Kotlin направлена на исключение опасности нулевых ссылок, также известной как "Миллиардная Ошибка".

Исключение возникает, когда происходит попытка получения доступа к члену нулевой ссылки. В **Java** и **Kotlin** это эквивалентно `NullPointerException`, или сокращённо `NPE`.

Причины возникновения `NPE` в **Kotlin**:

- Явный вызов `throw NullPointerException()`.
- Использование оператора `!!`, который описан ниже.
- Нарушение целостности данных относительно инициализации, такое как:
    1) Неинициализированный `this`, доступный в конструкторе, передается и используется в каком-то месте (утечка `this`).
    2) Конструктор суперкласса вызывает открытый элемент, реализация которого в производном классе использует неинициализированное состояние.
- Взаимодействие с **Java**:
    1) Попытки доступа к элементу нулевой ссылки платформенного типа;
    2) Проблемы с нулевой безопасностью при использовании обобщенных типов взаимодействия с **Java**. Например, **Java-код** может добавить `null` в `MutableList<String>`, требуя поэтому `MutableList<String?>` для работы с этим.
 
В **Kotlin** система типов различает между ссылками, которые могут содержать `null` (nullable references) и теми, которые не могут (non-nullable references). Например, обычная переменная типа `String` не может содержать `null`:
```kotlin
var a: String = "abc" // Регулярная инициализация подразумевает отсутствие возможности содержания null по умолчанию
a = null // ошибка компиляции
```

Чтобы разрешить использование `null`, можно объявить переменную как nullable string, написав `String?`:
```kotlin
var b: String? = "abc" // может быть установлено в null
b = null // ок
print(b)
```

Теперь, если при вызове метода или обращении к свойству объекта `a`, гарантируется, что это не вызовет `NPE`, поэтому следующий код будет безоапсным:
```kotlin
val l = a.length
```

Но если нужно получить доступ к тому же свойству объекта b, это не будет безопасным, и компилятор сообщит об ошибке:
```kotlin
val l = b.length // ошибка: переменная 'b' может быть null
```

Чтобы получить доступ к такой переменной можно явно проверить, является ли `b` null, и обработать два варианта отдельно:
```kt
val l = if (b != null) b.length else -1
```

Второй вариант доступа к свойству переменной, которая может быть `null`, - использование оператора безопасного вызова `?.`:
```kotlin
val a = "Kotlin"
val b: String? = null
println(b?.length)
println(a?.length) // Лишний безопасный вызов
```
Это возвращает `b.length`, если `b` не равно `null`, и `null` в противном случае. Тип выражения здесь - `Int?`.

Чтобы выполнить определенную операцию только для непустых значений, вы можете использовать оператор безопасного вызова вместе с `let`:
```kotlin
val listWithNulls: List<String?> = listOf("Kotlin", null)
for (item in listWithNulls) {
    item?.let { println(it) } // выводит "Kotlin" и игнорирует null
}
```

Безопасный вызов также может быть размещен слева от оператора присваивания. Тогда, если один из получателей в цепочке безопасных вызовов равен `null`, присваивание пропускается, и выражение справа вообще не вычисляется:
```kt
// Если `person` или `person.department` равны `null`, функция не вызывается:
person?.department?.head = managersPool.getManager()
```

### Виды написания составных слов. В каких случаях используется тот или иной тип? 
Ответ:

### Что такое лямбда-выражение? Зачему они нужны? Что такое функция высшего порядка? Где в Kotlin они используются?
[Источник](https://kotlinlang.ru/docs/lambdas.html)

Функции высшего порядка и лямбда-выражения в Kotlin часто используются для более гибкого и читаемого программирования, включая работу с коллекциями, обработку событий, асинхронное программирование и другие сценарии.

#### Лямбда-выражения
Лямбда-выражения и анонимные функции - это **функциональный литерал**, то есть необъявленная функция, которая немедленно используется в качестве выражения. 

Полная синтаксическая форма лямбда-выражений может быть представлена следующим образом:
```kt
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
```
- Лямбда-выражение всегда заключено в скобки `{...}`;
- Объявление параметров при таком синтаксисе происходит внутри этих скобок и может включать в себя аннотации типов;
- Тело функции начинается после знака `->`;
- Если тип возвращаемого значения не `Unit`, то в качестве возвращаемого типа принимается последнее (а возможно и единственное) выражение внутри тела лямбды.
Если вы вынесите все необязательные объявления, то, что останется, будет выглядеть следующим образом:
```kt
val sum = { x: Int, y: Int -> x + y }
```

Лямбда выражения полезны для:
- **Упрощения кода**: Лямбда-выражения позволяют записывать компактный код, особенно при передаче их в качестве аргументов функций.
- **Использования в функциях высшего порядка**: Лямбда-выражения активно используются в функциях высшего порядка для передачи функций в качестве параметров или возврата из функций.

#### Функции высшего порядка 

Функция высшего порядка - это функция, которая принимает функции как параметры, или возвращает функцию в качестве результата.
```kt
fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

val sum: (Int, Int) -> Int = { x, y -> x + y }
val product: (Int, Int) -> Int = { x, y -> x * y }

val resultSum = operateOnNumbers(3, 5, sum) // Вызов функции с лямбда-выражением
val resultProduct = operateOnNumbers(3, 5, product)

println(resultSum)     // Выведет: 8
println(resultProduct) // Выведет: 15
```
В этом примере `operateOnNumbers` — это функция высшего порядка, которая принимает два числа и функцию, выполняющую операцию над числами. Затем мы создаем две лямбда-функции `sum` и `product` и передаем их в `operateOnNumbers` для выполнения различных операций.

#### Дополнительно

```kt
max(strings, { a, b -> a.length < b.length })
```
Функция `max` является функцией высшего порядка, потому что она принимает функцию в качестве второго аргумента. Этот второй аргумент является выражением, которое в свою очередь есть функция, то есть **функциональный литерал**. Как функция он эквивалентен объявлению:
```kt
fun compare(a: String, b: String): Boolean = a.length < b.length
```

В Kotlin существует соглашение: если последний параметр функции является функцией, то лямбда-выражение, переданное в качестве соответствующего аргумента, может быть вынесено за круглые скобки.
```kt
val product = items.fold(1) { acc, e -> acc * e }
```
Такой синтаксис также известен как `trailing lambda`.

Когда лямбда-выражение является единственным аргументом функции, круглые скобки могут быть опущены.
```kt
run { println("...") }
```

## Тема 3. Принципы и концепции программирования 

### Что представляют собой принципы SOLID в контексте программирования? 
Ответ:

### Объясните принципы KISS и DRY. Для чего сформулированы эти принципы? 
Ответ:

### Каковы основные парадигмы программирования и в чем их отличительные особенности? 
Ответ:

### Что такое ООП? Устно приведите пример реализации каждого принципа на Koltin. Каковы основные достоинства и недостатки этой парадигмы программирования? 
Ответ:

