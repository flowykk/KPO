# КПО. Модуль 2. Темы к коллоквиуму
## Формат проведения
Коллоквиум пройдет в режиме собеседования. Каждому студенту выдается по три
небольших теоретических вопроса по каждой из трех тем. Необходимо сразу дать
ответы без подготовки. Преподаватель может задать дополнительные вопросы по
каждой из тем. На основе полученных ответов формируется три промежуточных
оценки:

О_Т1 - оценка за устный ответ по теме 1.

О_Т2 - оценка за устный ответ по теме 2.

О_Т3 - оценка за устный ответ по теме 3.

#### Итоговая оценка за коллоквиум:
О_КР2 = (О_Т1 + О_Т2 + ОТ_3) / 3.
Максимальная оценка 8 баллов.

## Тема 1. Основы языка UML
#### [Что такое UML и каково его основное назначение?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-uml-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B2%D0%BE-%D0%B5%D0%B3%D0%BE-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-1)
#### [Какие основные типы диаграмм используются в UML? Объясните, для чего эти диаграммы применяются.](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D0%B2-uml-%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D1%8D%D1%82%D0%B8-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D1%8E%D1%82%D1%81%D1%8F-1)
#### [Какой функционал необходимо описать при моделировании системы заказов доставки посылок?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B8%CC%86-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%B8-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B7%D0%B0%D0%BA%D0%B0%D0%B7%D0%BE%D0%B2-%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B8-%D0%BF%D0%BE%D1%81%D1%8B%D0%BB%D0%BE%D0%BA)
#### [Кратко опишите, какие классы необходимы для моделирования системы заказов посылок? Какие связи необходимы между классами?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE-%D0%BE%D0%BF%D0%B8%D1%88%D0%B8%D1%82%D0%B5-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B7%D0%B0%D0%BA%D0%B0%D0%B7%D0%BE%D0%B2-%D0%BF%D0%BE%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D0%B2%D1%8F%D0%B7%D0%B8-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC%D0%B8-1)
#### [Кратко опишите диаграмму последовательностей для прецедента авторизации пользователя.](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE-%D0%BE%D0%BF%D0%B8%D1%88%D0%B8%D1%82%D0%B5-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%83-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9%CC%86-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%B5%D1%86%D0%B5%D0%B4%D0%B5%D0%BD%D1%82%D0%B0-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
#### [Кратко опишите диаграмму активностей для прецедента авторизации пользователя.](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE-%D0%BE%D0%BF%D0%B8%D1%88%D0%B8%D1%82%D0%B5-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%83-%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%B5%D1%86%D0%B5%D0%B4%D0%B5%D0%BD%D1%82%D0%B0-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F-1)
## Тема 2. Основы языка программирования Kotlin
#### [Зачем нужны классы? Как создаются классы в Kotlin? Что такое блок init? Что такое primary constructor? В каком порядке они вызываются?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BA%D0%B0%D0%BA-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B2-kotlin-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA-init-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-primary-constructor-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5-%D0%BE%D0%BD%D0%B8-%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%D1%81%D1%8F-1)
#### [Какими способами можно создать свойство в Kotlin? Зачем классам нужны свойства?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC%D0%B8-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B0%D0%BC%D0%B8-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D0%B8%CC%86%D1%81%D1%82%D0%B2%D0%BE-%D0%B2-kotlin-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%81%D0%B2%D0%BE%D0%B8%CC%86%D1%81%D1%82%D0%B2%D0%B0)
#### [Зачем применяют наследование? Как наследуются интерфейсы и классы в Kotlin?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D1%8E%D1%82-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B8%CC%86%D1%81%D1%8B-%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B2-kotlin)
#### [Какие основные структуры данных имеются в Kotlin. Зачем они нужны?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D0%BC%D0%B5%D1%8E%D1%82%D1%81%D1%8F-%D0%B2-kotlin-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-1)
#### [Что такое null-безопасность в Kotlin? Зачем она нужна?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-null-%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B2-kotlin-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B0-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-1)
#### [Виды написания составных слов. В каких случаях используется тот или иной тип?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%B2%D0%B8%D0%B4%D1%8B-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D1%85-%D1%81%D0%BB%D0%BE%D0%B2-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D1%8F%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-%D1%82%D0%BE%D1%82-%D0%B8%D0%BB%D0%B8-%D0%B8%D0%BD%D0%BE%D0%B8%CC%86-%D1%82%D0%B8%D0%BF)
#### [Что такое лямбда-выражение? Зачему они нужны? Что такое функция высшего порядка? Где в Kotlin они используются?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC%D1%83-%D0%BE%D0%BD%D0%B8-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0-%D0%B3%D0%B4%D0%B5-%D0%B2-kotlin-%D0%BE%D0%BD%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-1)
## Тема 3. Принципы и концепции программирования
#### [Что представляют собой принципы SOLID в контексте программирования?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82-%D1%81%D0%BE%D0%B1%D0%BE%D0%B8%CC%86-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-solid-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
#### [Объясните принципы KISS и DRY. Для чего сформулированы эти принципы?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-kiss-%D0%B8-dry-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D1%81%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D1%8B-%D1%8D%D1%82%D0%B8-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-1)
#### [Каковы основные парадигмы программирования и в чем их отличительные особенности?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B2%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%B2-%D1%87%D0%B5%D0%BC-%D0%B8%D1%85-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-1)
#### [Что такое ООП? Устно приведите пример реализации каждого принципа на Koltin. Каковы основные достоинства и недостатки этой парадигмы программирования?](https://github.com/flowykk/KPO/blob/main/kollok.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D0%BE%D0%BF-%D1%83%D1%81%D1%82%D0%BD%D0%BE-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B8%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%B0-%D0%BD%D0%B0-koltin-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B2%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8-%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8-%D1%8D%D1%82%D0%BE%D0%B8%CC%86-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

# КПО. Модуль 2. Ответы на вопросы

## Тема 1. Основы языка UML 

### Что такое UML и каково его основное назначение?

**UML (Unified Modeling Language)** - это стандартный язык моделирования, разработанный для облегчения процесса проектирования и анализа систем, особенно в области разработки программного обеспечения. UML предоставляет графический набор элементов и нотаций для создания визуальных представлений различных аспектов системы. Он является эффективным средством для коммуникации между членами команды разработки, а также для взаимодействия с заказчиками и другими заинтересованными сторонами.

### Какие основные типы диаграмм используются в UML? Объясните, для чего эти диаграммы применяются. 

Вот основные типы диаграмм в UML:

#### Диаграмма классов (Class Diagram)

__Цель:__ Моделирование структуры системы, её классов, атрибутов и методов.

__Применение:__ Используется для визуализации структуры классов, их атрибутов, методов и отношений между классами.

#### Диаграмма вариантов использования (Use Case Diagram)

__Цель:__ Описывает функциональность системы с точки зрения внешних акторов.

__Применение:__ Используется для идентификации основных сценариев использования системы и взаимодействия с внешними акторами.

#### Диаграмма последовательности (Sequence Diagram)

__Цель:__ Показывает взаимодействие объектов во времени, обозначая порядок вызовов методов.

__Применение:__ Используется для моделирования динамического поведения системы, особенно взаимодействия между объектами.

#### Диаграмма активности (Activity Diagram)

__Цель:__ Моделирование потоков работы (рабочих процессов) и деятельности в системе.

__Применение:__ Используется для визуализации бизнес-процессов, алгоритмов или общих потоков работы.

### Какой функционал необходимо описать при моделировании системы заказов доставки посылок? 
Ответ:

### Кратко опишите, какие классы необходимы для моделирования системы заказов посылок? Какие связи необходимы между классами? 
Ответ:

### Кратко опишите диаграмму последовательностей̆ для прецедента авторизации пользователя. 
Ответ:

### Кратко опишите диаграмму активностей для прецедента авторизации пользователя. 
Ответ:

## Тема 2. Основы языка программирования Kotlin 

### Зачем нужны классы? Как создаются классы в Kotlin? Что такое блок init? Что такое primary constructor? В каком порядке они вызываются? 

[Источник 1](https://kotlinlang.ru/docs/classes.html)

[Источник 2](https://kotlinlang.ru/docs/properties.html)

В любом языке программирования классы играют важную роль и используются для:
- Удобства и читаемости кода
- Структурирования кода, разделения программ на логические части и блоки
- Создания ООП-программ
- Инкапсуляции: ограничения доступа к данным и методам, ведь данные, определенные внутри класса, могут быть закрытыми (`private`), что обеспечивает контроль над доступом и изменением данных.

Классы в Kotlin объявляются с использованием ключевого слова class:
```kt
class Person { /*...*/ }
```
Объявление класса состоит из имени класса, заголовка класса (определения его типовых параметров, основного конструктора и некоторых других вещей) и тела класса, заключенного в фигурные скобки `{}`. 

Как заголовок, так и тело являются необязательными; если у класса нет тела, фигурные скобки можно опустить. Тогда получится пустой класс
```kt
class Empty
```

Класс имеет **primary-конструктор** и, возможно, один или несколько **secondary-конструкторов**. Основной конструктор объявляется в заголовке класса и следует за именем класса с ключевым словом `constructor` и необязательными типовыми параметрами.
```kt
class Person constructor(firstName: String) { /*...*/ }
```

Если основной конструктор не имеет аннотаций (`@`) или модификаторов видимости, ключевое слово `constructor` можно опустить:
```kt
class Person(firstName: String) { /*...*/ }
```

Заголовок класса не может содержать выполняемый код. Поэтому, если нужно выполнять какой-то код во время создания объекта, можно использовать блоки инициализации `init` внутри тела класса. Блоки инициализации объявляются с использованием ключевого слова `init`, за которым следуют фигурные скобки, а внутри них - код, который будет выполняться при создании объектов класса.

Во время инициализации экземпляра блоки инициализации выполняются в том же порядке, в котором они появляются в теле класса:

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints $name")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
```

При создании экземпляра класса в Kotlin сначала вызывается `primary-конструктор`, затем выполняется блок `init` (если он присутствует). 

### Какими способами можно создать свойство в Kotlin? Зачем классам нужны свойства? 

[Источник](https://kotlinlang.ru/docs/properties.html)

Свойства позволяют вложить дополнительную логику, которая может быть необходима при установке или получении значения. Они могут иметь различные уровни доступа, их можно использовать для проверки и валидации данных, переданных пользователем, или для автоматического обновления других свойств или полей при изменении значений.

Свойства в классах Kotlin могут быть объявлены либо как изменяемые (`mutable`), с использованием ключевого слова `var`, либо как доступные только для чтения (`read-only`), с использованием ключевого слова `val`.

```kotlin
class Address {
    var name: String = "Холмс, Шерлок"
    var street: String = "Бейкер"
    var city: String = "Лондон"
    var state: String? = null
    var zip: String = "123456"
}
```

Полный синтаксис объявления свойства выглядит следующим образом:
```kotlin
var <имяСвойства>[: <ТипСвойства>] [= <инициализаторСвойства>]
    [<геттер>]
    [<сеттер>]
```

Указывание инициализатора, `getter'а` и `setter'a` является необязательным. Тип свойства также необязателен, если его можно вывести из инициализатора или возвращаемого типа геттера, как показано ниже:
```kotlin
var initialized = 1 // имеет тип Int, геттер и сеттер по умолчанию
// var allByDefault // ОШИБКА: требуется явный инициализатор, подразумеваются геттер и сеттер по умолчанию
```

При определении собственного `getter'a`, он будет вызываться каждый раз при доступе к свойству (таким образом, можно реализовать вычисляемое свойство).
```kotlin
class Rectangle(val width: Int, val height: Int) {
    val area: Int // тип свойства необязателен, так как его можно вывести из возвращаемого типа геттера
        get() = this.width * this.height
}
```

Вы можете опустить тип свойства, если его можно вывести из `getter'a`:
```kotlin
val area get() = this.width * this.height
```

При определении собственного `setter'a`, он будет вызываться каждый раз при присвоении значения свойству, за исключением его инициализации. Собственный `setter` выглядит следующим образом:
```kotlin
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // разбирает строку и присваивает значения другим свойствам
    }
```
По соглашению, имя параметра сеттера - `value`, но можно выбрать другое имя, если предпочтительно.

Свойства можно инициализировать из основного конструктора, при этом можно задать им значения по умолчанию:
```kotlin
class Person(val firstName: String, val lastName: String, var isEmployed: Boolean = true)
```

#### Дополнительно

Если вам нужно аннотировать аксессор или изменить его видимость, но вы не хотите изменять реализацию по умолчанию, вы можете определить аксессор, не определяя его тело:
```kotlin
var setterVisibility: String = "abc"
    private set // сеттер является закрытым и имеет реализацию по умолчанию

var setterWithAnnotation: Any? = null
    @Inject set // аннотируйте сеттер аннотацией Inject
```

### Зачем применяют наследование? Как наследуются интерфейсы и классы в Kotlin? 
[Источник](https://kotlinlang.ru/docs/inheritance.html)

Наследование в программировании предоставляет механизм создания новых классов на основе существующих (родительских) классов. Это позволяет создавать иерархии классов, где новые классы могут наследовать свойства и методы родительских классов, а также добавлять или переопределять их.

Основные цели применения наследования:
- **Повторное использование кода**: Наследование позволяет создавать новые классы на основе существующих, повторно используя их функциональность.
- **Структурирование кода**: Иерархии классов помогают организовать код и создавать абстракции, которые отражают отношения между различными объектами.

#### Наследование

Для всех классов в **Kotlin** родительским суперклассом является класс `Any`. Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс.
```kt
class Example // Неявно наследуется от Any
```
У `Any` есть три метода: `equals()`, `hashCode()` и `toString()`. Эти методы определены для всех классов в **Kotlin**.

По умолчанию все классы в **Kotlin** имеют статус `final`, который блокирует возможность наследования. Чтобы сделать класс наследуемым, его нужно пометить ключевым словом `open`.
```kt
open class Base // Класс открыт для наследования
```

Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:
```kt
open class Base(p: Int)

class Derived(p: Int) : Base(p)
```
Если у класса есть основной конструктор, базовый тип может (и должен) быть проинициализирован там же, с использованием параметров основного конструктора.

Если у класса нет основного конструктора, тогда каждый последующий дополнительный конструктор должен включать в себя инициализацию базового типа с помощью ключевого слова `super` или давать отсылку на другой конструктор, который это делает. Примечательно, что любые дополнительные конструкторы могут ссылаться на разные конструкторы базового типа.
```kt
class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```

#### Переопределение методов класса

**Kotlin** требует явно указывать модификаторы и для членов, которые могут быть переопределены, и для самого переопределения.
```kt
open class Shape {
    open fun draw() { /*...*/ }
    fun fill() { /*...*/ }
}

class Circle() : Shape() {
    override fun draw() { /*...*/ }
}
```
Для `Circle.draw()` необходим модификатор override. В случае её отсутствия компилятор выдаст ошибку. Если у функции типа `Shape.fill()` нет модификатора `open`, объявление метода с такой же сигнатурой в производном классе невозможно, с `override` или без. Модификатор `open` не действует при добавлении к членам `final` класса (т.е. класса без модификатора open).

Член класса, помеченный `override`, является сам по себе `open`, т.е. он может быть переопределён в производных классах. Если вы хотите запретить возможность переопределения такого члена, используйте `final`.
```kt
open class Rectangle() : Shape() {
    final override fun draw() { /*...*/ }
}
```

#### Переопределение свойств класса

Переопределение свойств работает также, как и переопределение методов; все свойства, унаследованные от суперкласса, должны быть помечены ключевым словом `override`, а также должны иметь совместимый тип. Каждое объявленное свойство может быть переопределено свойством с инициализацией или свойством с `get`-методом.
```kt
open class Shape {
    open val vertexCount: Int = 0
}

class Rectangle : Shape() {
    override val vertexCount = 4
}
```

Вы также можете переопределить свойство `val` свойством `var`, но не наоборот. Это разрешено, поскольку свойство `val` объявляет `get`-метод, а при переопределении его как `var` дополнительно объявляется `set`-метод в производном классе.

Обратите внимание, что ключевое слово `override` может быть использовано в основном конструкторе класса как часть объявления свойства.
```kt
interface Shape {
    val vertexCount: Int
}

class Rectangle(override val vertexCount: Int = 4) : Shape // Всегда имеет 4 вершины

class Polygon : Shape {
    override var vertexCount: Int = 0  // Может быть установлено любое количество
}
```

#### Порядок инициализации производного класса
При создании нового экземпляра класса в первую очередь выполняется инициализация базового класса (этому шагу предшествует только оценка аргументов, передаваемых в конструктор базового класса) и, таким образом, происходит до запуска логики инициализации производного класса.
```kt
open class Base(val name: String) {

    init { println("Инициализация класса Base") }

    open val size: Int = 
        name.length.also { println("Инициализация свойства size в класса Base: $it") }
}

class Derived(
    name: String,
    val lastName: String,
) : Base(name.replaceFirstChar { it.uppercase() }.also { println("Аргументы, переданные в конструктор класса Base: $it") }) {

    init { println("Инициализация класса Derived") }

    override val size: Int =
        (super.size + lastName.length).also { println("Инициализация свойства size в классе Derived: $it") }
}

fun main() {
    println("Построение класса Derived(\"hello\", \"world\")")
    Derived("hello", "world")
}
```
При запуске кода получим
```
Построение класса Derived("hello", "world")
Аргументы, переданные в конструктор класса Base: Hello
Инициализация класса Base
Инициализация свойства size в класса Base: 5
Инициализация класса Derived
Инициализация свойства size в классе Derived: 10
```
Это означает, что свойства, объявленные или переопределенные в производном классе, не инициализированы к моменту вызова конструктора базового класса. Если какое-либо из этих свойств используется в логике инициализации базового класса (прямо или косвенно через другую переопределенную `open` реализацию члена класса), это может привести к некорректному поведению или сбою во время выполнения. Поэтому при разработке базового класса следует избегать использования членов с ключевым словом `open` в конструкторах, инициализации свойств и блоков инициализации (`init`).

#### Наследование интерфейсов
Наследование интерфейсов в **Kotlin** предоставляет механизм, который позволяет классу реализовать функциональность, определенную в интерфейсе. Интерфейс определяет набор методов, который класс, реализующий интерфейс, должен предоставить.
```kt
interface Walkable {
    fun walk()
}

class Dog : Walkable {
    override fun walk() {
        println("Dog is walking")
    }
}
```
В приведенном примере, интерфейс `Walkable` содержит единственный метод `walk()`. А класс `Dog` реализует интерфейс `Walkable`. Для этого мы используем `:`, указываем имя интерфейса (`Walkable`), и в теле класса предоставляем реализацию метода `walk()`.

Класс может реализовывать несколько интерфейсов. Когда класс реализует несколько интерфейсов, он обязан предоставить реализации всех методов из каждого интерфейса.
```kt
class FlyingDog : Walkable, Flyable {
    override fun walk() {
        println("FlyingDog is walking")
    }

    override fun fly() {
        println("FlyingDog is flying")
    }
}
```

Когда класс наследует интерфейс, он обязан предоставить реализации всех методов, определенных в этом интерфейсе. Если класс не предоставляет реализацию всех методов, то он должен быть объявлен как абстрактный (`abstract`).
```kt
abstract class AbstractDog : Walkable {
    // Класс AbstractDog является абстрактным и не предоставляет реализацию метода walk()
}
```

Интерфейсы могут содержать реализацию методов, что позволяет им предоставлять методы по умолчанию. Класс, реализующий такой интерфейс, может использовать реализацию по умолчанию или переопределить метод.
```kt
interface Talkable {
    fun talk() {
        println("Talking...")
    }
}

class Parrot : Talkable

class Human : Talkable {
    override fun talk() {
        println("Human is talking loudly")
    }
}
```

Интерфейс может быть производным от других интерфейсов, что означает, что он может как предоставлять реализации для их членов, так и объявлять новые функции и свойства. Вполне естественно, что классы, реализующие такой интерфейс, требуются только для определения отсутствующих реализаций.
```kt
interface Named {
    val name: String
}

interface Person : Named {
    val firstName: String
    val lastName: String
    
    override val name: String get() = "$firstName $lastName"
}

data class Employee(
    // реализация 'name' не требуется
    override val firstName: String,
    override val lastName: String,
    val position: Position
) : Person
```

#### Дополнительно
#### Устранение противоречий при переопределении
Когда мы объявляем большое количество типов в списке нашего супертипа, может так выйти, что мы допустим более одной реализации одного и того же метода.
```kt
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }
    
    override fun bar() {
        super<B>.bar()
    }
}
```
Оба интерфейса `A` и `B` объявляют функции `foo()` и `bar()`. Оба реализуют `foo()`, но только B содержит реализацию `bar()` (`bar()` не отмечен как абстрактный метод в интерфейсе `A`, потому что в интерфейсах это подразумевается по умолчанию, если у функции нет тела). Теперь, если вы унаследуете какой-нибудь класс `C` от интерфейса `A`, вам, очевидно, придётся переопределять метод `bar()`, обеспечивая его реализацию.

Однако если вы унаследуете класс `D` от интерфейсов `A` и `B`, вам надо будет переопределять все методы, унаследованные от этих интерфейсов, и вам нужно указать, как именно `D` должен их реализовать. Это правило касается как тех методов, у которых имеется только одна реализация (`bar()`), так и тех, у которых есть несколько реализаций (`foo()`).

#### Вызов функций и свойств суперкласса
Производный класс может вызывать реализацию функций и свойств своего суперкласса, используя ключевое слово `super`.
```kt
open class Rectangle {
    open fun draw() { println("Рисование прямоугольника") }
    val borderColor: String get() = "black"
}

class FilledRectangle : Rectangle() {
    override fun draw() {
        super.draw()
        println("Заполнение прямоугольника")
    }

    val fillColor: String get() = super.borderColor
}
```

Во внутреннем классе доступ к суперклассу внешнего класса осуществляется при помощи ключевого слова `super`, за которым следует имя внешнего класса: `super@Outer`.
```kt
class FilledRectangle: Rectangle() {
    override fun draw() {
        val filler = Filler()
        filler.drawAndFill()
    }

    inner class Filler {
        fun fill() { println("Filling") }
        fun drawAndFill() {
            super@FilledRectangle.draw() // Вызывает реализацию функции draw() класса Rectangle
            fill()
            println("Нарисованный прямоугольник заполнен ${super@FilledRectangle.borderColor} цветом") // Используется реализация get()-метода свойства borderColor в классе
        }
    }
}
```

### Какие основные структуры данных имеются в Kotlin. Зачем они нужны?

[Источник](https://kotlinlang.ru/docs/collections-overview.html)

Структуры нужны, чтобы упорядочивать, искать, анализировать и использовать данные с применением алгоритмов программирования.

`Array (массив)` - это упорядоченная коллекция элементов одного типа, к которым можно обращаться по индексам, представляя собой фиксированный размер последовательности.
```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
```

`List (список)` - упорядоченная коллекция, в которой к элементам можно обращаться по индексам — целым числам, отражающим положение элементов в коллекции. Идентичные элементы (дубликаты) могут встречаться в списке более одного раза. 
```kt
// Неизменяемый список
val names: List<String> = listOf("Alice", "Bob", "Charlie")
// Изменяемый список
val mutableNames: MutableList<String> = mutableListOf("Alice", "Bob", "Charlie")

// Добавление элемента в изменяемый список
mutableNames.add("David")
```
Элементы списка (в том числе `null`) могут дублироваться: список может содержать любое количество одинаковых объектов. Два списка считаются равными, если они имеют одинаковый размер и их элементы в одних и тех позициях структурно равны.

`Set (множество)` - коллекция уникальных элементов. Отражает математическую абстракцию множества: группа объектов без повторов. Как правило, порядок расположения элементов здесь не имеет значения.
```kt
// Неизменяемое множество
val uniqueNumbers: Set<Int> = setOf(1, 2, 3, 4, 5)
// Изменяемое множество
val mutableSet: MutableSet<Int> = mutableSetOf(1, 2, 3, 4, 5)

// Добавление элемента в изменяемое множество
mutableSet.add(6)
```
`null` также является уникальным элементом: `Set` может содержать только один `null`. Два множества равны, если они имеют одинаковый размер и для каждого элемента множества есть равный элемент в другом множестве.

`Map (словарь, ассоциативный список)` - набор из пар "ключ-значение". Ключи уникальны и каждый из них соответствует ровно одному значению. Значения могут иметь дубликаты.
```kt
// Неизменяемый словарь
val ages: Map<String, Int> = mapOf("Alice" to 25, "Bob" to 30, "Charlie" to 22)
// Изменяемый словарь
val mutableAges: MutableMap<String, Int> = mutableMapOf("Alice" to 25, "Bob" to 30, "Charlie" to 22)

// Добавление новой пары ключ-значение в изменяемое отображение
mutableAges["David"] = 28
```
`Map` хранит пары "ключ-значение" (или _entries_); ключи уникальны, но разные ключи могут иметь одинаковые значения. Интерфейс `Map` предоставляет такие функции, как доступ к значению по ключу, поиск ключей и значений и т. д. Две `Map`-ы, содержащие равные пары, равны независимо от порядка пар.

#### Дополнительно

Неизменяемые типы коллекций ковариантны. Это означает, что если класс `Rectangle` наследуется от `Shape`, вы можете использовать `List<Rectangle>` там, где требуется `List<Shape>`. Другими словами, типы коллекций имеют такое же отношение подтипов, что и типы элементов. `Map`-ы ковариантны по типу значения, но не по типу ключа.

В свою очередь, изменяемые коллекции не являются ковариантными; в противном случае это привело бы к сбоям во время выполнения. Если `MutableList<Rectangle>` был подтипом `MutableList<Shape>`, вы могли добавить в него других наследников `Shape` (например, `Circle`), таким образом нарушая изначальный тип коллекции - `Rectangle`.

`List`, `Set` - наследники `Collection`. `Collection<T>` является корнем в иерархии коллекций. Этот интерфейс представляет собой обычное поведение неизменяемой коллекции: операции типа `size`, `get` и т. д. `Collection` наследуется от интерфейса `Iterable<T>`, который определяет операции для итерации элементов.

`Stack (стек)` - это абстрактная структура данных, следующая принципу "последний вошел, первый вышел" (Last-In-First-Out, LIFO). Это означает, что последний добавленный элемент будет первым, который будет извлечен. Операции добавления элемента называются "push", а удаления - "pop". Стек может быть использован для обработки данных в порядке обратном порядку ввода.
```kt
val stack: Stack<Int> = Stack()
stack.push(1)
stack.push(2)
```

`Queue (очередь)` - это абстрактная структура данных, следующая принципу "первый вошел, первый вышел" (First-In-First-Out, FIFO). Это означает, что первый добавленный элемент будет первым, который будет извлечен. Операции добавления элемента называются "enqueue", а удаления - "dequeue". Очередь может быть использована для управления элементами в порядке ввода.
```kt
val queue: Queue<String> = LinkedList()
queue.offer("First")
queue.offer("Second")
```

### Что такое null-безопасность в Kotlin? Зачем она нужна? 
Система типов Kotlin направлена на исключение опасности нулевых ссылок, также известной как "Миллиардная Ошибка".

Исключение возникает, когда происходит попытка получения доступа к члену нулевой ссылки. В **Java** и **Kotlin** это эквивалентно `NullPointerException`, или сокращённо `NPE`.

Причины возникновения `NPE` в **Kotlin**:

- Явный вызов `throw NullPointerException()`.
- Использование оператора `!!`, который описан ниже.
- Нарушение целостности данных относительно инициализации, такое как:
    1) Неинициализированный `this`, доступный в конструкторе, передается и используется в каком-то месте (утечка `this`).
    2) Конструктор суперкласса вызывает открытый элемент, реализация которого в производном классе использует неинициализированное состояние.
- Взаимодействие с **Java**:
    1) Попытки доступа к элементу нулевой ссылки платформенного типа;
    2) Проблемы с нулевой безопасностью при использовании обобщенных типов взаимодействия с **Java**. Например, **Java-код** может добавить `null` в `MutableList<String>`, требуя поэтому `MutableList<String?>` для работы с этим.
 
В **Kotlin** система типов различает между ссылками, которые могут содержать `null` (nullable references) и теми, которые не могут (non-nullable references). Например, обычная переменная типа `String` не может содержать `null`:
```kotlin
var a: String = "abc" // Регулярная инициализация подразумевает отсутствие возможности содержания null по умолчанию
a = null // ошибка компиляции
```

Чтобы разрешить использование `null`, можно объявить переменную как nullable string, написав `String?`:
```kotlin
var b: String? = "abc" // может быть установлено в null
b = null // ок
print(b)
```

Теперь, если при вызове метода или обращении к свойству объекта `a`, гарантируется, что это не вызовет `NPE`, поэтому следующий код будет безоапсным:
```kotlin
val l = a.length
```

Но если нужно получить доступ к тому же свойству объекта b, это не будет безопасным, и компилятор сообщит об ошибке:
```kotlin
val l = b.length // ошибка: переменная 'b' может быть null
```

Чтобы получить доступ к такой переменной можно явно проверить, является ли `b` null, и обработать два варианта отдельно:
```kt
val l = if (b != null) b.length else -1
```

#### Оператор `?.`

Второй вариант доступа к свойству переменной, которая может быть `null`, - использование оператора безопасного вызова `?.`:
```kotlin
val a = "Kotlin"
val b: String? = null
println(b?.length)
println(a?.length) // Лишний безопасный вызов
```
Это возвращает `b.length`, если `b` не равно `null`, и `null` в противном случае. Тип выражения здесь - `Int?`.

#### Элвис-оператор `?`

Если выражение, стоящее слева от Элвис-оператора, не является `null`, то элвис-оператор его вернёт. В противном случае в качестве возвращаемого значения послужит то, что стоит справа. Обращаем ваше внимание на то, что часть кода, расположенная справа, выполняется ТОЛЬКО в случае, если слева получается `null`.
```kt
val l = b?.length ?: -1
```

**Дополнительно про Элвис-оператор**: Так как `throw` и `return` тоже являются выражениями в **Kotlin**, их также можно использовать справа от _Элвис-оператора_. Это может быть крайне полезным для проверки аргументов функции.
```kt
fun foo(node: Node): String? {
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
    // ...
}
```

#### Оператор `!!`

Оператор _not-null_ (`!!`) преобразует любое значение в _non-null_ тип и выдает исключение, если значение равно `null`. Вы можете написать `b!!` и это вернёт нам либо _non-null_ значение `b` (в нашем примере вернётся `String`), либо выкинет `NPE`, если `b` равно `null`.
```kt
val l = b!!.length
```
В случае, если вам нужен `NPE`, вы можете заполучить её только путём явного указания.

#### Оператор let

Чтобы выполнить определенную операцию только для непустых значений, вы можете использовать оператор безопасного вызова вместе с `let`:
```kotlin
val listWithNulls: List<String?> = listOf("Kotlin", null)
for (item in listWithNulls) {
    item?.let { println(it) } // выводит "Kotlin" и игнорирует null
}
```

Безопасный вызов также может быть размещен слева от оператора присваивания. Тогда, если один из получателей в цепочке безопасных вызовов равен `null`, присваивание пропускается, и выражение справа вообще не вычисляется:
```kt
// Если `person` или `person.department` равны `null`, функция не вызывается:
person?.department?.head = managersPool.getManager()
```

#### Дополнительно

#### Безопасные приведения типов
Обычное приведение типа может вызвать `ClassCastException` в случае, если объект имеет другой тип. Можно использовать безопасное приведение, которое вернёт `null`, если попытка не удалась.
```kt
val aInt: Int? = a as? Int
```

### Виды написания составных слов. В каких случаях используется тот или иной тип? 

#### Camel Case

**Пример:** myVariableName, calculateTotalAmount, getUserInfo

**Правило:** Первое слово начинается с маленькой буквы, каждое последующее слово начинается с большой буквы.

**Когда используется:** Часто используется для именования переменных и методов.
```kt
val myVariableName = 42
fun calculateSum(a: Int, b: Int): Int {
    return a + b
}
```

#### Upper Camel Case (Pascal Case):

**Пример:** MyClassName

**Правило:** Все слова начинаются с большой буквы, включая первое слово.

**Когда используется:** В основном спользуется для именования классов.
```kt
class MyClass {
    // ...
}
```

#### Snake Case:

**Пример:** my_variable_name, calculate_total_amount, get_user_info

**Правило:** Все слова написаны строчными буквами, разделены символом подчеркивания _.

**Когда используется:** Применяется не так часто, но иногда используется для именования свойств классов, свойств объектов `JSON`, свойств `config`-файлов.
```kt
data class ApiResponse(
    val user_id: Int,
    val user_name: String,
    val is_active: Boolean
)
```
```kt
val configData = mapOf(
    "max_connections" to 100,
    "timeout_seconds" to 30
)
```

#### Kebab Case (в Kotlin не рекомендуется, но упоминается):

**Пример:** my-variable-name, my-text-file

**Правило:** Все слова написаны строчными буквами, разделены дефисом -.

**Когда используется:** Используется очень редко, но иногда для написания файловых имён или URL
```kt
val myFileContent = readFile("my-text-file.txt")
val imageUrl = "https://example.com/my-image.jpg"
val apiEndpoint = "https://api.example.com/data-endpoint"
```

Самыми частоиспользуемыми стилями являются `Camel case` и `Pascal case` Эти стили нужны для того, чтобы повысить читаемость кода.  Выбор стиля зачастую зависит от предпочтений команды или стандартов, принятых в проекте. Важно придерживаться выбранного стиля для обеспечения читаемости кода и его единообразия.

### Что такое лямбда-выражение? Зачему они нужны? Что такое функция высшего порядка? Где в Kotlin они используются?
[Источник](https://kotlinlang.ru/docs/lambdas.html)

Функции высшего порядка и лямбда-выражения в Kotlin часто используются для более гибкого и читаемого программирования, включая работу с коллекциями, обработку событий, асинхронное программирование и другие сценарии.

#### Лямбда-выражения
Лямбда-выражения и анонимные функции - это **функциональный литерал**, то есть необъявленная функция, которая немедленно используется в качестве выражения. 

Полная синтаксическая форма лямбда-выражений может быть представлена следующим образом:
```kt
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
```
- Лямбда-выражение всегда заключено в скобки `{...}`;
- Объявление параметров при таком синтаксисе происходит внутри этих скобок и может включать в себя аннотации типов;
- Тело функции начинается после знака `->`;
- Если тип возвращаемого значения не `Unit`, то в качестве возвращаемого типа принимается последнее (а возможно и единственное) выражение внутри тела лямбды.
Если вы вынесите все необязательные объявления, то, что останется, будет выглядеть следующим образом:
```kt
val sum = { x: Int, y: Int -> x + y }
```

Лямбда выражения полезны для:
- **Упрощения кода**: Лямбда-выражения позволяют записывать компактный код, особенно при передаче их в качестве аргументов функций.
- **Использования в функциях высшего порядка**: Лямбда-выражения активно используются в функциях высшего порядка для передачи функций в качестве параметров или возврата из функций.

#### Несколько примеров синтаксиса лямбда выражений
```kt
val sum: (Int, Int) -> Int = { a, b -> a + b }
```

```kt
val square: (Int) -> Int = { it * it }
```

```kt
val printMessage: (String) -> Unit = { message ->
    println("Message: $message")
}
```

#### Функции высшего порядка 

Функция высшего порядка - это функция, которая принимает функции как параметры, или возвращает функцию в качестве результата.
```kt
fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

val sum: (Int, Int) -> Int = { x, y -> x + y }
val product: (Int, Int) -> Int = { x, y -> x * y }

val resultSum = operateOnNumbers(3, 5, sum) // Вызов функции с лямбда-выражением
val resultProduct = operateOnNumbers(3, 5, product)

println(resultSum)     // Выведет: 8
println(resultProduct) // Выведет: 15
```
В этом примере `operateOnNumbers` — это функция высшего порядка, которая принимает два числа и функцию, выполняющую операцию над числами. Затем мы создаем две лямбда-функции `sum` и `product` и передаем их в `operateOnNumbers` для выполнения различных операций.

#### Дополнительно

```kt
max(strings, { a, b -> a.length < b.length })
```
Функция `max` является функцией высшего порядка, потому что она принимает функцию в качестве второго аргумента. Этот второй аргумент является выражением, которое в свою очередь есть функция, то есть **функциональный литерал**. Как функция он эквивалентен объявлению:
```kt
fun compare(a: String, b: String): Boolean = a.length < b.length
```

В Kotlin существует соглашение: если последний параметр функции является функцией, то лямбда-выражение, переданное в качестве соответствующего аргумента, может быть вынесено за круглые скобки.
```kt
val product = items.fold(1) { acc, e -> acc * e }
```
Такой синтаксис также известен как `trailing lambda`.

Когда лямбда-выражение является единственным аргументом функции, круглые скобки могут быть опущены.
```kt
run { println("...") }
```

## Тема 3. Принципы и концепции программирования 

### Что представляют собой принципы SOLID в контексте программирования? 
SOLID описывает 5 принципов проектирования и программирования. Каждая буква – отдельный принцип.

#### S – Single responsibility principle (принцип едиснтвенной ответственности)
Если у класса много ответственностей, это увеличивает возможность возникновения багов (так как изменения в
одном, могут повлиять на другое).

<img width="700" alt="Снимок экрана 2023-12-14 в 17 43 40" src="https://github.com/flowykk/KPO/assets/71427624/3ff01c95-97e3-401b-8e23-1cdc4bc36095">

#### O – Open-closed principle (принцип открытого-закрытого)
Классы должны быть открыты для расширения, но закрыты для изменения. Изменения в поведении класса воздействуют на все системы, что использовали этот класс. Стремимся добавлять функции, а не изменять их.

<img width="700" alt="Снимок экрана 2023-12-14 в 17 46 16" src="https://github.com/flowykk/KPO/assets/71427624/3bd5bd1f-6f73-4972-ba6b-f7b910ea6df6">

#### L – Liskov substitution principle (принцип подстановки Лисков)
Если S – подтип T, то объекты типа T можно заменить на объекты типа S безболезненно и без каких-либо других изменений в программе.

<img width="700" alt="Снимок экрана 2023-12-14 в 17 46 47" src="https://github.com/flowykk/KPO/assets/71427624/24e3fb47-cdee-44da-9640-a6efff7275b4">

#### I – Interface Segregation principle (принцип разделения интерфейса)
Клиентам ну нужно навязывать зависимость от методов, которые они не используют. Класс должен выполнить только те действия, которые необходимы, чтобы выполнить роль. Выделяем более мелкие классы и интерфейсы.

<img width="700" alt="Снимок экрана 2023-12-14 в 17 47 04" src="https://github.com/flowykk/KPO/assets/71427624/2f8dfe84-cf9f-4a32-bfa2-6e85563b9215">

#### D – Dependency Inversion principle (принцип инверсии зависимостей)
Модули верхних уровней не должны зависеть от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Класс и используемый им инструмент лучше не объединять, а использовать интерфейс, который можно использовать с разными инструментами.

<img width="700" alt="Снимок экрана 2023-12-14 в 17 47 59" src="https://github.com/flowykk/KPO/assets/71427624/f9ee90f7-0558-4718-91b3-e357b7793d92">

### Объясните принципы KISS и DRY. Для чего сформулированы эти принципы? 

#### KISS
_Keep it simple, stupid. («Делай проще, тупица»)_
Там, где можно сделать проще, лучше сделать проще, чем выдумывать велосипед.
- **Суть**: Принцип KISS подразумевает, что решения должны быть максимально простыми и понятными. Не стоит усложнять код или архитектуру, если это не требуется.
- **Цель**: Упростить код, сделать его более читаемым и понятным, чтобы другие разработчики (и сам автор) могли легко вносить изменения и поддерживать систему.

#### DRY
_Don’t repeat yourself. («Не повторяйся»)_
Этот принцип настолько важен, что не требует повторения!
Разделяя систему на компоненты, можно добиться состояния, когда каждая часть системы отвечает только за определенные действия. Конкретно эти части должны иметь одно представление в коде.
- **Суть**: Принцип DRY призывает к тому, чтобы избегать дублирования кода. Если у вас есть повторяющиеся фрагменты кода, их следует вынести в отдельные функции, классы или модули.
- **Цель**: Уменьшить повторение кода для улучшения его сопровождаемости и предотвращения возможных ошибок, связанных с несинхронизированным изменением дублированного кода.

#### Цели и преимущества принципов KISS и DRY:
- **Читаемость и понимание кода**: Простой и не повторяющийся код легче читать и понимать. Это особенно важно в среде командной разработки, где различные разработчики могут работать с одним проектом.
- **Легкость сопровождения**: Принципы KISS и DRY способствуют созданию кода, который легко изменять и обслуживать. Это уменьшает риск внесения ошибок при внесении изменений.
- **Эффективность и производительность**: Простота и отсутствие дублирования способствуют более эффективной разработке. Код, который легко понимать и изменять, уменьшает время на разработку и улучшает продуктивность.
- **Повторное использование кода**: Уменьшение дублирования кода позволяет повторно использовать компоненты и функции, что снижает объем работы при создании новых функциональных возможностей.

### Каковы основные парадигмы программирования и в чем их отличительные особенности? 

#### Основные парадигмы программирования:
- _Императивная_ (Последовательность шагов и инструкций)
- _Функциональная_ (Программа описывается как набор функций)
- _Декларативная_ (Описываем результат)
- _Процедурная_ (Выделяем процедуры)
- _Объектно-ориентированная_
  
#### Императивное программирование

В этой парадигме программирования задача программы описывается как последовательность инструкций, изменяющих состояние программы. Основные концепции - операторы присваивания, циклы, условные операторы, переменные и изменяемые состояния.
_Примеры_: Языки `C`, `Pascal`, `Fortran`, `C++`, `Java`.

#### Функциональное программирование

Основной фокус на функциях как базовых строительных блоках программы. Функции могут передаваться как аргументы и возвращаться из других функций. Основной акцент делается на использовании функций высшего порядка, неизменяемости данных и отсутствии побочных эффектов.

#### Декларативное программирование

Программа представляет собой набор логических выражений, описывающих желаемое состояние или решение задачи. Система логических правил определяет порядок выполнения. Программист описывает _"что"_, а не _"как"_ должно быть выполнено.

#### Процедурное программирование

Программа разделяется на процедуры, которые выполняют определенные действия. Управление программой осуществляется последовательным вызовом процедур.

#### Объектно-ориентированное программирование

ООП-программа состоит из набора объектов, взаимодействующих
между собой, где объекты – экземпляры некоторого класса, могут содержать данные (поля) и методы для их обработки. А классы описывают: данные (внутреннюю реализацию) и интерфейс (поведение/методы).

### Что такое ООП? Устно приведите пример реализации каждого принципа на Koltin. Каковы основные достоинства и недостатки этой парадигмы программирования? 

ООП - парадигма программирования. ООП-программа состоит из набора объектов, взаимодействующих между собой, где объекты – экземпляры некоторого класса, могут содержать данные (поля) и методы для их обработки. А классы описывают: данные (внутреннюю реализацию) и интерфейс (поведение/методы).

#### Принципы ООП

- Абстрагирование
- Инкапсуляция
- Наследованные
- Полиморфизм

#### Абстрагирование

Принцип абстрагирования означает создание абстракций, которые скрывают детали реализации и предоставляют только необходимый интерфейс для взаимодействия с объектами. Абстрагирование позволяет упростить сложные системы, предоставляя высокоуровневые интерфейсы для использования.
```kt
// Абстрактный класс "Транспорт"
abstract class Transport {
    abstract fun start()  // Абстрактный метод для старта транспорта
    abstract fun stop()   // Абстрактный метод для остановки транспорта
}

// Класс "Автомобиль", который наследуется от "Транспорт"
class Car : Transport() {
    override fun start() {
        println("Car started")
    }

    override fun stop() {
        println("Car stopped")
    }

    fun drive() {
        println("Car is driving")
    }
}

// Класс "Самолет", который также наследуется от "Транспорт"
class Airplane : Transport() {
    override fun start() {
        println("Airplane started")
    }

    override fun stop() {
        println("Airplane stopped")
    }

    fun fly() {
        println("Airplane is flying")
    }
}

fun main() {
    val myCar = Car()
    myCar.start()
    myCar.drive()
    myCar.stop()

    val myAirplane = Airplane()
    myAirplane.start()
    myAirplane.fly()
    myAirplane.stop()
}
```
В данном примере `Transport` представляет абстракцию транспортного средства с методами `start()` и `stop()`. Классы `Car` и `Airplane` являются конкретными реализациями транспорта и предоставляют свои специфичные методы (`drive()` и `fly()` соответственно).

#### Инкапсуляция (сокрытие информации)
Под инкапсуляцией понимают «упаковку» данных и функций внутри общего компонента. Пресечение прямого доступа к некоторым атрибутам компонента.
```kt
class BankAccount(private var balance: Double, private val accountNumber: String) {

    // Метод для получения баланса
    fun getBalance(): Double {
        return balance
    }

    // Метод для внесения средств
    fun deposit(amount: Double) {
        if (amount > 0) {
            balance += amount
            println("$amount deposited. New balance: $balance")
        } else {
            println("Invalid deposit amount")
        }
    }

    // Метод для снятия средств
    fun withdraw(amount: Double) {
        if (amount > 0 && amount <= balance) {
            balance -= amount
            println("$amount withdrawn. New balance: $balance")
        } else {
            println("Invalid withdrawal amount")
        }
    }
}

fun main() {
    val account = BankAccount(1000.0, "1234567890")

    // Попытка прямого доступа к полям (неудачная, так как они закрыты модификатором private)
    // println(account.balance)  // Ошибка компиляции
    // println(account.accountNumber)  // Ошибка компиляции

    // Доступ к данным через методы класса
    println("Initial balance: ${account.getBalance()}")

    account.deposit(500.0)
    account.withdraw(200.0)
}
```
В данном примере класс `BankAccount` представляет собой модель банковского счета. Поля `balance` и `accountNumber` являются закрытыми (`private`), что означает, что они не могут быть прямо доступны извне класса. Вместо этого доступ осуществляется через методы `getBalance()`, `deposit()` и `withdraw()`.

#### Наследование 

Возможность экземпляров класса содержать в себе (наследовать) реализацию другого класса, включающую данные и методы. Класс-наследник уточняет определение базового класса, добавляя свои характеристики. 
```kt
// Пример наследования
open class Animal(val name: String) {
    fun eat() {
        println("$name is eating")
    }
}

class Dog(name: String, val breed: String) : Animal(name) {
    fun bark() {
        println("$name is barking")
    }
}

fun main() {
    val dog = Dog("Buddy", "Golden Retriever")
    dog.eat()
    dog.bark()
}
```

#### Полиморфизм 

Полиморфизм в программировании представляет собой способность объектов различных типов использовать одинаковые имена (методы или операторы) для выполнения различных действий. Он может проявляться в различных формах:

**Ad hoc (по случаю) полиморфизм:**

Одинаковое имя функции или оператора используется для различных типов данных или аргументов. например, перегрузка функций или операторов.
```kt
fun add(a: Int, b: Int): Int {
    return a + b
}

fun add(a: Double, b: Double): Double {
    return a + b
}
```

**Параметрический полиморфизм:**

Реализация алгоритма без ориентации на конкретный тип данных. Например: обобщенное программирование (использование шаблонов).
```kt
class Box<T>(val value: T)

fun <T> getValue(box: Box<T>): T {
    return box.value
}
```

**Полиморфизм включения (subtyping):**

Принцип подстановки Барбары Лисков (из вопроса про **SOLID**).
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. То есть объект более узкого типа всегда может использоваться там, где может использоваться объект более широкого типа. 
```kotlin
open class Shape {
    open fun draw() {
        println("Drawing a shape")
    }
}

class Circle : Shape() {
    override fun draw() {
        println("Drawing a circle")
    }
}

fun drawShape(shape: Shape) {
    shape.draw()
}
```

В этих примерах демонстрируется различные аспекты полиморфизма, который обеспечивает гибкость и повторное использование кода в программировании. **Ad hoc** полиморфизм предоставляет разные реализации для различных типов данных, **параметрический полиморфизм** предоставляет абстракцию от конкретного типа, а **полиморфизм включения** позволяет работать с разными подтипами через общий интерфейс.


